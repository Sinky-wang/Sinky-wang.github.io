{"title":"《ARM 嵌入式 Linux 系统开发详解》学习笔记 1","slug":"《ARM嵌入式Linux系统开发》学习笔记1","date":"2020-09-01","updated":"2020-09-10","comments":true,"path":"api/posts/64036.json","excerpt":null,"cover":"https://i.loli.net/2020/09/07/REugKvzkfIn7B58.png","covers":["https://i.loli.net/2020/09/07/REugKvzkfIn7B58.png"],"content":"<h1 id=\"0x01- 嵌入式系统入门\"><a href=\"#0x01- 嵌入式系统入门\" class=\"headerlink\" title=\"0x01 嵌入式系统入门\"></a>0x01 嵌入式系统入门 </h1><p><b> 什么是嵌入式系统：</b></p>\n<p>一种为特定设备服务的，软件硬件可裁剪的计算机系统，形式变化多样、体积小。如手机、微波炉，对于手机、微波炉来说，需要小型计算机来控制，换句话，是需要把计算机全入到手机和微波炉里，也就是嵌入式系统，不需要严格地响应时间和数据吞吐量，最关键的是能够缩小体积以及功能专门化，嵌入式系统种类繁多，按照系统硬件的核心处理器来说可以分成嵌入式微控制器和嵌入式微处理器。</p>\n<p><b>嵌入式微控制器：</b></p>\n<p>嵌入式微控制器也就是传统意义上的单片机，是目前嵌入式系统的前身。单片机就是把一个计算机的主要功能集成到一个芯片上，即一个芯片就是一个计算机，体积小、结构简单、便于开发以及价格经济。</p>\n<p>通常一个单片机芯片包含运算处理单元、ARM、Flash 存储器以及外部接口，通过外部接口可以输出或者输入心寒，控制相应的设备，用户可以把编写好的代码烧写到单片机芯片内部来控制外部设备。</p>\n<p><b>嵌入式微处理器：</b></p>\n<p>单片机处理能力低，嵌入式微处理器是最近几年随着大规模集成电路发展同步，处理能力更强，目前主流嵌入式微处理器都是 32 位，而单片机多是 8 位和 16 位。</p>\n<p><b>典型嵌入式系统组成：</b></p>\n<p>嵌入式系统与传统 PC 一样，也是一种及计算机系统，由硬件和软件组成，硬件包括嵌入式微控制器和微处理器，以及一些外围元器件和外部设备；软件包括嵌入式操作系统和应用软件。</p>\n<p>嵌入式系统种类繁多，不同的嵌入式系统软、硬件很难兼容，软件必须修改而硬件必须重新设计才能使用。</p>\n<p>典型嵌入式系统:</p>\n<ul>\n<li>硬件：<ul>\n<li>嵌入式处理器：处理器是整个系统的核心，负责处理所有的软件程序以及外部设备的信号</li>\n<li>外部设备：在不同系统中有不同选择。</li>\n</ul>\n</li>\n<li>软件：<ul>\n<li>嵌入式操作系统：是软硬件的接口，负责管理系统的所有软件和硬件资源，还可以通过驱动程序与外部设备打交道。</li>\n<li>应用软件：利用操作系统提供的功能开发出针对某个需求的程序，供用户使用。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"0x02- 嵌入式软硬件系统\"><a href=\"#0x02- 嵌入式软硬件系统\" class=\"headerlink\" title=\"0x02 嵌入式软硬件系统\"></a>0x02 嵌入式软硬件系统 </h1><p> 数字电路是计算机的基础。</p>\n<p>进制转换</p>\n<p>计算机组成原理</p>\n<p>直接内存访问：DMA</p>\n<p>软件：系统软件、应用软件</p>\n<p>软件开发：需求分析、概要设计和详细设计、编码和调试、测试和维护。</p>\n<p>常见软件开发模型：瀑布开发模型、增量开发模型、统一软件开发模型。</p>\n<p>操作系统的基本结构都是内核、驱动程序、程序库。</p>\n<h1 id=\"0x03-ARM 处理器\"><a href=\"#0x03-ARM 处理器\" class=\"headerlink\" title=\"0x03 ARM 处理器\"></a>0x03 ARM 处理器</h1><ul>\n<li>微处理器<ul>\n<li>通用微处理器：用于高性能计算</li>\n<li>嵌入式微处理器：针对某种特定应用的高能力计算</li>\n<li>微控制器：用于控制某种设备，通常集成了多种外部设备控制器，处理指令能力不强但价格低廉。</li>\n</ul>\n</li>\n</ul>\n<p>ARM: 高性能 RISC 机器。</p>\n<ul>\n<li>芯片体积小，功耗低，成本低性能优异</li>\n<li>支持 Thumb(16 位)和 ARM(32 位)</li>\n<li>内部大量使用寄存器，执行指令速度快。</li>\n<li>大部分指令是操作寄存器，很少访问外部内存</li>\n<li>采用多级流水线结构处理速度快。</li>\n<li>多种寻址方式，数据存取方式灵活</li>\n<li>指令长度固定，便于编译器操作以及执行指令</li>\n</ul>\n<h3 id=\"ARM 指令集\"><a href=\"#ARM 指令集\" class=\"headerlink\" title=\"ARM 指令集\"></a>ARM 指令集</h3><ul>\n<li>算术运算指令<ul>\n<li>ADD: 加法运算<ul>\n<li>add dest,op1,op2 //dest 是目的寄存器，op1 op2 是操作数,dest=op1+op2</li>\n</ul>\n</li>\n<li>ADC: 带进位加法<ul>\n<li>ADC dest,op1,op2</li>\n</ul>\n</li>\n<li>SUB: 减法<ul>\n<li>sub dest,op1,op2</li>\n<li>dest=op1-op2</li>\n</ul>\n</li>\n<li>SBC：带进位减法</li>\n</ul>\n</li>\n<li>逻辑运算指令<ul>\n<li>AND: 逻辑与(1 1 为 1，0 0 为 1，1 0 为 0)<ul>\n<li>and dest,op1,op2</li>\n<li>dest=op1 and op2</li>\n</ul>\n</li>\n<li>EOR: 异或（1 1 为 0，0 0 为 0，10 为 1）</li>\n<li>MOV: 复制数据<ul>\n<li>mov dest,op1</li>\n<li>dest=op1</li>\n<li>mov r0,r0,LSL#3//r0=r0*8,LSL 寄存器左移三位，即乘以 8</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>分支指令<ul>\n<li>B: 跳转<ul>\n<li>b 地址 // 跳转到指定地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据传送指令<ul>\n<li>单一数据传送指令：向内存装载和存储一个字节或一个字长的数据<ul>\n<li>LDR Rd, 地址</li>\n<li>STR Rd, 地址</li>\n<li>LDR B Rd, 地址</li>\n<li>STR B Rd, 地址 </li>\n</ul>\n</li>\n<li>多数据传送指令：向内存装载和存储多个字节或字的数据<ul>\n<li>xxM Rn(!),&lt; 寄存器列表 &gt;{^}</li>\n<li>xx:LD–装载，ST–存储</li>\n<li>LDMED LDMIB//++i</li>\n<li>LDMFD LDMIA//i++</li>\n<li>LDMEA LDMDB//++*i</li>\n<li>LDMFA LDMDA//*i++</li>\n<li>STMFA STMIB// 存储前增加地址</li>\n<li>STMEA STMIA// 存储后增加地址</li>\n<li>STMFD STMDB// 存储前增加值</li>\n<li>STMED STMDA// 存储后增加值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>ARM 状态：0 位表示 ARM 状态，1 位表示 Thumb 状态,BX 指令切换状态。</p>\n<p>MMU: 内存管理单元。</p>\n<blockquote>\n<p>LSL: 逻辑左移，二进制从右往左移动，空位补 0（就是原数值乘以 2 的移位次方）<br>LSR: 逻辑右移，二进制从左往右，空位补 0<br>ASR: 算术右移，符号位不变，高位空出补 0，低位补 1<br>ROR: 循环右移，低位移到高位<br>RRX: 带扩展的循环右移：操作数右移一位，高端空出位用原 C 标志值填充</p>\n</blockquote>\n<h3 id=\"寻址方式\"><a href=\"# 寻址方式\" class=\"headerlink\" title=\"寻址方式\"></a>寻址方式</h3><ul>\n<li>立即寻址: 用 #表示数值<ul>\n<li>subs r0,#1;r0=r0-1</li>\n<li>mov r0,#0xff00;r0=0xff00</li>\n</ul>\n</li>\n<li>寄存器寻址方式：读取寄存器得到操作数<ul>\n<li>mov r1,r2;r1=r2</li>\n<li>sub r0,r1,r2;r0=r1-r2</li>\n</ul>\n</li>\n<li>寄存器偏移寻址：寄存器的值移位得结果<ul>\n<li>mov r0,r1,LSL #3;r0=r1*8</li>\n<li>ands r0,r2,LSL #3;r0= r2*8 and r1</li>\n</ul>\n</li>\n<li>寄存器间接寻址：寄存器为地址，从对应内存重取出数据<ul>\n<li>LDR r0,[r1];r1 为地址，从内存中取出数据存入 r0</li>\n<li>SWP r0,r0,[r1];r1 为地址，从内存中取出数据与 r0 交换</li>\n</ul>\n</li>\n<li>基址寻址：把寄存器内容与指定便宜相加，得数据地址，后从内存中取出数据<ul>\n<li>LDR r0,[r1,#0xf];r1 数值与 0xf 相加得到数据地址</li>\n<li>STR r0,[r1,#-2];r1 数值 -2 得到数据地址</li>\n</ul>\n</li>\n<li>多寄存器寻址：一次传输多个寄存器值<ul>\n<li>LDMIA r1!,{r2<del>r7,r12};r1 单元重数据读到 r2</del>r7 和 r12,r1 指定地址自动加 1</li>\n</ul>\n</li>\n<li>栈寻址：先进后出，通过栈指针寄存器寻址<ul>\n<li>STMFD SP!,{R0<del>R7,LR};r0</del>r7 和 LR 的内容压入堆栈</li>\n<li>LDMFD SP!,{r0<del>r7,LR}; 从堆栈中取出数据到 r0</del>r7 和 LR</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"0x04- 嵌入式 Linux\"><a href=\"#0x04- 嵌入式 Linux\" class=\"headerlink\" title=\"0x04 嵌入式 Linux\"></a>0x04 嵌入式 Linux</h1><p>一般来说，嵌入式操作系统是由启动程序、核心、根文件系统组成，通过特殊的烧录工具将编译好的嵌入式系统文件影像烧写到目标板的只读存储器（ROM）或 Flash 存储器中。</p>\n<h1 id=\"0x05- 建立软件开发环境\"><a href=\"#0x05- 建立软件开发环境\" class=\"headerlink\" title=\"0x05 建立软件开发环境\"></a>0x05 建立软件开发环境</h1><ul>\n<li>运行在 windows 平台下得到 Linux 系统模拟环境：Cygwin.</li>\n<li>linux 下：串口工具 minicom</li>\n<li>windows 下：串口工具 xshell</li>\n<li>ARM 集成开发环境 ADS<ul>\n<li>c 语言编译器 armcc</li>\n<li>c++ 语言编译器 armcpp</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"0x06- 第一个 linux 应用程序\"><a href=\"#0x06- 第一个 linux 应用程序\" class=\"headerlink\" title=\"0x06 第一个 linux 应用程序\"></a>0x06 第一个 linux 应用程序</h1><ul>\n<li>vi 创建源代码文件 hello.c</li>\n<li>gcc -c hello.c 编译运行<h1 id=\"0x07-Linux 应用程序编程基础\"><a href=\"#0x07-Linux 应用程序编程基础\" class=\"headerlink\" title=\"0x07 Linux 应用程序编程基础\"></a>0x07 Linux 应用程序编程基础</h1></li>\n<li>堆栈</li>\n<li>内存管理函数<ul>\n<li>malloc(): 分配内存，不能初始化内存空间</li>\n<li>free()：释放 malloc()分配的内存</li>\n</ul>\n</li>\n<li>实用的内存分配函数<ul>\n<li>calloc(): 分配一块新内存，向应用程序分诶内存，分配后会初始化新分配的内存空间</li>\n<li>realloc(): 改变一块已经分配的内存大小，函数调整后的内存空间起始地址有可能与原来的不同，所以需要 realloc()函数的返回值。</li>\n</ul>\n</li>\n<li>文件指针和流：FILE*fp</li>\n<li>getc() /fgetc() /getchar()</li>\n<li>POSIX 文件 I/O 编程<ul>\n<li>POSIX 可移植操作系统接口</li>\n<li>open() /creat() /close() /read() /write() /fcnt()修改一打开文件属性</li>\n<li>文件头：<ul>\n<li>&lt;sys/types.h&gt;</li>\n<li>&lt;sys/stat.h&gt;</li>\n<li>&lt;fcntl.h&gt;<h1 id=\"0x08- 开发多进程 - 线程程序\"><a href=\"#0x08- 开发多进程 - 线程程序\" class=\"headerlink\" title=\"0x08 开发多进程 / 线程程序\"></a>0x08 开发多进程 / 线程程序</h1></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>PCB 进程控制块</li>\n<li>fork()调用创建进程</li>\n<li>退出进程：exit()、_exit()、atexit()、on_exit().</li>\n<li>常用进程间通信方法：<ul>\n<li>管道：单方向传送数据，只能在有共同父进程的进程间使用<ul>\n<li>pipe()函数：创建管道</li>\n<li>#include&lt;unistd.h&gt; int pipe(int filedes[1]);</li>\n</ul>\n</li>\n<li>共享内存：不同进程可访问<ul>\n<li>int shmget(): 创建</li>\n<li>void *shmat：获得一个共享内存 ID 对应的内存其实地址</li>\n<li>int shmdt：从程序中分立一块共享内存</li>\n</ul>\n</li>\n<li>FIFO</li>\n<li>消息队列</li>\n<li>信号量</li>\n<li>共享存储</li>\n<li>socker</li>\n</ul>\n</li>\n<li>Linux 的多进程和多线程</li>\n</ul>\n<h1 id=\"0x09- 网络通信应用\"><a href=\"#0x09- 网络通信应用\" class=\"headerlink\" title=\"0x09 网络通信应用\"></a>0x09 网络通信应用</h1><ul>\n<li>TCP/IP 协议簇</li>\n</ul>\n<p><img src=\"https://i.loli.net/2020/09/07/REugKvzkfIn7B58.png\" alt=\"捕获.PNG\"></p>\n","url":"/posts/64036/","min2read":8,"word4post":"2.2k","prev_post":{"title":"DDCTF RE windows_re2","url":"/posts/2874/"},"next_post":{"title":"RPC 入侵：MS06-040 与 MS08-067","url":"/posts/59247/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x01- 嵌入式系统入门\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">0x01 嵌入式系统入门 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x02- 嵌入式软硬件系统\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">0x02 嵌入式软硬件系统 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x03-ARM 处理器\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">0x03 ARM 处理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"ARM 指令集\" href = \"#\"><span class=\"toc-number\">3.0.1.</span> <span class=\"toc-text\">ARM 指令集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"寻址方式\" href = \"#\"><span class=\"toc-number\">3.0.2.</span> <span class=\"toc-text\">寻址方式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x04- 嵌入式 Linux\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">0x04 嵌入式 Linux</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x05- 建立软件开发环境\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">0x05 建立软件开发环境</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x06- 第一个 linux 应用程序\" href = \"#\"><span class=\"toc-number\">6.</span> <span class=\"toc-text\">0x06 第一个 linux 应用程序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x07-Linux 应用程序编程基础\" href = \"#\"><span class=\"toc-number\">7.</span> <span class=\"toc-text\">0x07 Linux 应用程序编程基础</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x08- 开发多进程 - 线程程序\" href = \"#\"><span class=\"toc-number\">8.</span> <span class=\"toc-text\">0x08 开发多进程 &#x2F; 线程程序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x09- 网络通信应用\" href = \"#\"><span class=\"toc-number\">9.</span> <span class=\"toc-text\">0x09 网络通信应用</span></a></li></ol>","categories":[],"tags":[{"name":"学习笔记","path":"api/tags/学习笔记.json","url":"/tags/学习笔记/"}]}