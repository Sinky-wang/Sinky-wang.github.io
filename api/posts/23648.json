{"title":"MIPS 架构学习笔记","slug":"MIPS架构学习笔记","date":"2020-09-07","updated":"2020-09-10","comments":true,"path":"api/posts/23648.json","excerpt":null,"cover":null,"covers":null,"content":"<h1 id=\"0x01- 寄存器\"><a href=\"#0x01- 寄存器\" class=\"headerlink\" title=\"0x01 寄存器\"></a>0x01 寄存器</h1><h3 id=\"32 个通用寄存器：-0-31-32 位\"><a href=\"#32 个通用寄存器：-0-31-32 位\" class=\"headerlink\" title=\"32 个通用寄存器：$0-$31,32 位\"></a>32 个通用寄存器：$0-$31,32 位</h3><p>MIPS32 中通用寄存器的约定用法：</p>\n<p>|:–:|:–:|<br>| 寄存器名字 | 约定名字 | 用途 |<br>|$0|zero| 总是为 0|<br>|$1|at| 留作汇编器生成一些合成指令 |<br>|$2 $3|v0 v1| 用来存放子程序返回值 |<br>|$4<del>$7|a0</del>a3| 调用子程序时，使用这 4 个寄存器传输前 4 个非浮点参数 |<br>|$8<del>$15|t0</del>t7| 临时寄存器，子程序使用时可以不用存储和恢复 |<br>|$16<del>$23|s0</del>s7| 子程序寄存器变量，改变这些寄存器值的子程序必须存储旧的值并在退出前恢复，对调用程序来说值不变 |<br>|$24 $25|t8 t9| 临时寄存器，子程序使用时可以不用存储和恢复 |<br>|$26 $27|$k0 $k1| 由异常处理程序使用 |<br>|$28 或 $gp|gp| 全局指针 |<br>|$29 或 $sp|sp| 堆栈指针 |<br>|$30 或 $fp|s8/sp| 子程序可以用来做堆栈帧指针 |<br>|$31|ra| 存放子程序返回地址 |</p>\n<h3 id=\"特殊寄存器\"><a href=\"# 特殊寄存器\" class=\"headerlink\" title=\"特殊寄存器\"></a>特殊寄存器</h3><ul>\n<li>PC: 程序计数器</li>\n<li>HI: 乘除结果高位寄存器</li>\n<li>LO: 乘除结果低位寄存器</li>\n</ul>\n<p><b>MIPS 架构属于小端模式</b></p>\n<h3 id=\"MIPS 指令\"><a href=\"#MIPS 指令\" class=\"headerlink\" title=\"MIPS 指令\"></a>MIPS 指令</h3><p>|:—-:|:—-:|<br>| 指令 | 功能 |<br>|LB| 从存储器中读取一个字节的数据到寄存器中 |<br>|LH| 从存储器中读取半个字的数据到寄存器中 |<br>|LW| 从存储器中读取一个字的数据到寄存器中 |<br>|LD| 从存储器中读取双字的数据到寄存器中 |<br>|L.S| 从存储器中读取单精度浮点数到寄存器中 |<br>|L.D| 从存储器中读取双精度浮点数到寄存器中 |<br>|LBU|=LB, 无符号数据 |<br>|LHU|=LH, 无符号数据 |<br>|LWU|=LW, 无符号数据 |<br>|SB| 把一个字节的数据从寄存器存储到存储器中 |<br>|SH| 把半个字节的数据从寄存器存储到存储器中 |<br>|SW| 把一个字的数据从寄存器存储到存储器中 |<br>|SD| 把两个字节的数据从寄存器存储到存储器中 |<br>|S.S| 把单精度浮点数从寄存器存储到存储器中 |<br>|S.D| 把双精度数据从存储器存储到存储器中 |<br>|DADD| 把两个定点寄存器的内容相加，即定点加 |<br>|DADDI| 把一个寄存器的内容加上一个立即数 |<br>|DADDU| 不带符号的加 |<br>|DADDIU| 把一个寄存器的内容加上一个无符号的立即数 |<br>|ADD.S| 把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数 |<br>|ADD.D| 把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数 |<br>|ADD.PS| 两个单精度浮点数相加，结果是单精度浮点数 |<br>|DSUB| 两个寄存器的内容相减 |<br>|DSUBU| 不带符号的减 |<br>|SUB.S| 一个双精度浮点数减去一个单精度浮点数，结果是单精度浮点数 |<br>|SUB.D| 一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数 |<br>|SUB.PS| 两个单精度浮点数相减 |<br>|DDIV| 两个顶点寄存器的内容相除 |<br>|DDIVU| 不带符号的除法运算 |<br>|DIV.S| 双精度浮点数除以单精度浮点数，结果为单精度浮点数 |<br>|DIV.D| 双精度浮点数除以单精度浮点数，结果为双精度浮点数 |<br>|DIV.PS| 两个单精度浮点数相除，结果为单精度 |<br>|DMUL| 两个定点寄存器的内容相乘 |<br>|DMULU| 无符号相乘 |<br>|MUL.S| 双浮点乘单浮点得单浮点 |<br>|MUL.D| 双浮点乘单浮点得双浮点 |<br>|MUL.PS| 两个单浮点乘，得单浮点 |<br>|AND| 与运算 |<br>|ANDI| 一个寄存器中的内容与一个立即数相与 |<br>|OR| 或运算 |<br>|ORI||<br>|XOR| 异或 |<br>|XORI||<br>|BEQZ| 条件转移指令，当寄存器中内容为 0 时转移发生 |<br>|BENZ| 条件转移指令，寄存器内容不为 0 时转移发生 |<br>|BEQ| 条件转移指令，两个寄存器内容相等是转移发生 |<br>|BNE| 条件转移指令，两个寄存器中内容不等时转移发生 |<br>|J| 直接跳转指令，跳转的地址在指令中 |<br>|JR| 使用寄存器的跳转指令，跳转的地址在寄存器中 |<br>|JAL| 直接跳转指令，带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到 R31 寄存器中 |<br>|JALR| 使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在 R31|<br>|MOV.S| 把单浮点数从浮点寄存器复制到另一个浮点寄存器 |<br>|MOV.D| 把一个双浮点数从一个浮点寄存器复制到另一个浮点寄存器 |<br>|MFC0| 把一个数据从通用寄存器复制到特殊寄存器 |<br>|MTC0| 把一个数据从特殊寄存器复制到通用寄存器 |<br>|MFC1| 把一个数据从定点寄存器复制到浮点寄存器 |<br>|MTC1| 把一个数据从浮点寄存器复制到定点寄存器 |<br>|LUI| 把一个 16 位的立即数填入到寄存器的高 16 位，低 16 位补零 |<br>|DSLL| 双字逻辑左移 |<br>|DSRL| 双字逻辑右移 |<br>|DSRA| 双字算术右移 |<br>|DSLLV| 可变的双字逻辑左移 |<br>|DSRLV| 可变的双字逻辑右移 |<br>|DSRAV| 可变的双字算术右移 |<br>|SLT| 如果 r2 的值小于 r3，设置 r1 为 1，否在设置 r1 为 0|<br>|SLTI|r2 的值小于立即数，则 r1 为 1，否则为 0|<br>|SLTU|=SLT 带符号 |<br>|SLTUI|=SLT 不带符号 |<br>|MOVN| 若第三个寄存器内容为负，那么复制一个寄存器内容到另一个寄存器 |<br>|MOVZ| 若第三个寄存器内容为 0，则复制一个寄存器的内容到另一个寄存器 |<br>|TRAP| 根据地址向量转入管态 |<br>|ERET| 从异常中返回到用户态 |<br>|MADD.S| 一个双浮点数与单浮点数相乘加，结果为单 |<br>|MADD.D| 一个双浮点数与单浮点数相乘加，结果为双 |<br>|MADD.PS| 两个单浮点数相乘加，结果为单 |</p>\n<h3 id=\"大端序小端序复习\"><a href=\"# 大端序小端序复习\" class=\"headerlink\" title=\"大端序小端序复习\"></a>大端序小端序复习 </h3><p> 字节序，又称端序，尾须序，大小端序与硬件的体系结构有关，所有 x86 系列的 pc 机都是小断续，与操作系统无关，</p>\n<p>大端字节序，高子杰存于内存低地址，弟子姐姐存于内存搞地质，小端字节序反之。</p>\n","url":"/posts/23648/","min2read":6,"word4post":"1.7k","prev_post":{"title":"Ubuntu 下 buildroot 以及 qemu 环境搭建","url":"/posts/2371/"},"next_post":{"title":"DDCTF RE windows_re2","url":"/posts/2874/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x01- 寄存器\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">0x01 寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"32 个通用寄存器：-0-31-32 位\" href = \"#\"><span class=\"toc-number\">1.0.1.</span> <span class=\"toc-text\">32 个通用寄存器：$0-$31,32 位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"特殊寄存器\" href = \"#\"><span class=\"toc-number\">1.0.2.</span> <span class=\"toc-text\">特殊寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"MIPS 指令\" href = \"#\"><span class=\"toc-number\">1.0.3.</span> <span class=\"toc-text\">MIPS 指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"大端序小端序复习\" href = \"#\"><span class=\"toc-number\">1.0.4.</span> <span class=\"toc-text\">大端序小端序复习 </span></a></li></ol></li></ol></li></ol>","categories":[],"tags":[{"name":"IOT","path":"api/tags/IOT.json","url":"/tags/IOT/"}]}