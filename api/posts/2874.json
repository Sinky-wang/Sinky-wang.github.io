{"title":"DDCTF RE windows_re2","slug":"DDCTF2019re","date":"2020-09-04","updated":"2020-09-10","comments":true,"path":"api/posts/2874.json","excerpt":null,"cover":null,"covers":null,"content":"<p>esp 定律脱壳 Aspack，然后 ida 分析一波。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sub_401320()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v1; &#x2F;&#x2F; [esp+8h] [ebp-C04h]</span><br><span class=\"line\">  char v2; &#x2F;&#x2F; [esp+9h] [ebp-C03h]</span><br><span class=\"line\">  char v3; &#x2F;&#x2F; [esp+408h] [ebp-804h]</span><br><span class=\"line\">  char v4; &#x2F;&#x2F; [esp+409h] [ebp-803h]</span><br><span class=\"line\">  char v5; &#x2F;&#x2F; [esp+808h] [ebp-404h]</span><br><span class=\"line\">  char v6; &#x2F;&#x2F; [esp+809h] [ebp-403h]</span><br><span class=\"line\">  v3 &#x3D; 0;</span><br><span class=\"line\">  sub_401C6A(&amp;v4, 0, 0x3FF);</span><br><span class=\"line\">  v5 &#x3D; 0;</span><br><span class=\"line\">  sub_401C6A(&amp;v6, 0, 0x3FF);</span><br><span class=\"line\">  MEMORY[0x785520C1](&quot;input code:&quot;);</span><br><span class=\"line\">  MEMORY[0x785526D4](&quot;%s&quot;, &amp;v3);</span><br><span class=\"line\">  if (!(unsigned __int8)sub_4011F0())</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    MEMORY[0x785520C1](&quot;invalid input\\n&quot;);</span><br><span class=\"line\">    MEMORY[0x78542455](0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sub_401240(&amp;v5);</span><br><span class=\"line\">  v1 &#x3D; 0;</span><br><span class=\"line\">  sub_401C6A(&amp;v2, 0, 0x3FF);</span><br><span class=\"line\">  MEMORY[0x78552E73](&amp;v1, &quot;DDCTF&#123;%s&#125;&quot;, &amp;v5);</span><br><span class=\"line\">  if (!strcmp(&amp;v1, &quot;DDCTF&#123;reverse+&#125;&quot;) )</span><br><span class=\"line\">    MEMORY[0x785520C1](&quot;You&#39;ve got it !!! %s\\n&quot;, &amp;v1);</span><br><span class=\"line\">  else</span><br><span class=\"line\">    MEMORY[0x785520C1](&quot;Something wrong. Try again...\\n&quot;);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>限制输入 0-9,A-F, 可想到十六进制</li>\n<li>输入字符经过变换与“DDCTF{reverse+}”对比，相同则成功。</li>\n</ul>\n<p>先尝试输入字符串 <code>1234567AAA</code>, 得到加密后字符 <code>EjRWeqo=</code>, 看着像 base664, 直接 base64 转成十六进制尝试，发现得到了我输入字符串。<br> 将<code>reverse+</code>转换得到 flag</p>\n","url":"/posts/2874/","min2read":1,"word4post":251,"prev_post":{"title":"MIPS 架构学习笔记","url":"/posts/23648/"},"next_post":{"title":"《ARM 嵌入式 Linux 系统开发详解》学习笔记 1","url":"/posts/64036/"},"toc":"","categories":[],"tags":[{"name":"RE","path":"api/tags/RE.json","url":"/tags/RE/"}]}