{"title":"各类型软件漏洞合集","slug":"类型漏洞合集","date":"2020-08-24","updated":"2020-09-10","comments":true,"path":"api/posts/61516.json","excerpt":null,"cover":null,"covers":null,"content":"<h1 id=\"0x01- 格式化串漏洞\"><a href=\"#0x01- 格式化串漏洞\" class=\"headerlink\" title=\"0x01 格式化串漏洞\"></a>0x01 格式化串漏洞 </h1><h2 id=\"介绍\"><a href=\"# 介绍\" class=\"headerlink\" title=\"介绍\"></a> 介绍 </h2><p> 格式化串漏洞产生于数据输出函数中对输出格式解析的缺陷。当输入输出函数的格式控制符能够被外界影响时，攻击者可以利用读写内存的方法修改函数返回地址，劫持进程，使 shellcoed 得到执行。</p>\n<p>此类漏洞发生条件苛刻，实际案例很少。</p>\n<h2 id=\"能够引起此漏洞的函数\"><a href=\"# 能够引起此漏洞的函数\" class=\"headerlink\" title=\"能够引起此漏洞的函数\"></a>能够引起此漏洞的函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int printf(const char* format [,argument]...);</span><br><span class=\"line\">int wprintf(const wchar_t* format [,argument]...);</span><br><span class=\"line\">int fwprintf(FILE* stream,const wchar_t* format [,argument]...);</span><br><span class=\"line\">int sprintf(char buffer,const char* format [,argument]...);</span><br><span class=\"line\">int swprintf(wchar_t *buffer,const wchar_t *format [,argument]...);</span><br><span class=\"line\">int vprintf(const char* format,va_list argptr);</span><br><span class=\"line\">int vwprintf(const wchar_t* format,va_list argptr);</span><br><span class=\"line\">int vfprintf(FILE *stream,const char* format,va_list argptr);</span><br><span class=\"line\">int vfwprintf(FILE *stream,const wchar_t* format,va_list argptr);</span><br><span class=\"line\">int vsprintf(char *buffer,const char* format,va_list argptr);</span><br><span class=\"line\">int vswprintf(wchar_t *buffer,const wchar_t* format,va_list argptr);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"0x02-GS 安全编译选项保护\"><a href=\"#0x02-GS 安全编译选项保护\" class=\"headerlink\" title=\"0x02 GS 安全编译选项保护\"></a>0x02 GS 安全编译选项保护 </h1><h2 id=\"介绍 -1\"><a href=\"# 介绍 -1\" class=\"headerlink\" title=\"介绍\"></a> 介绍 </h2><p> 在所有函数调用发生时，GS 编译选项会向栈帧内压入一个额外的随机 DWORD, 这个随机数被称为 canary，在 EBP 前，系统在.data 内存区存放了 canary 副本，函数返回前系统会执行安全验证操作，比较栈帧中 canary 与内存区副本是否一致，不一致则证明发生溢出，系统将进行异常处理。</p>\n<h2 id=\"以下情况不会应用 GS\"><a href=\"# 以下情况不会应用 GS\" class=\"headerlink\" title=\"以下情况不会应用 GS\"></a>以下情况不会应用 GS</h2><ul>\n<li>函数不包含缓冲区</li>\n<li>函数被定义为具有变量参数列表</li>\n<li>函数使用无保护的关键字标记</li>\n<li>函数在第一个语句中包含内嵌汇编代码</li>\n<li>缓冲区不是 8 字节类型且大小不大于 4 个字节。</li>\n</ul>\n<h2 id=\"典型突破 GS 的方法\"><a href=\"# 典型突破 GS 的方法\" class=\"headerlink\" title=\"典型突破 GS 的方法\"></a>典型突破 GS 的方法 </h2><h3 id=\"利用未保护的内存\"><a href=\"# 利用未保护的内存\" class=\"headerlink\" title=\"利用未保护的内存\"></a> 利用未保护的内存 </h3><p> 为了将 GS 对性能的影响降到最小，并不会所有的函数都会被保护，我们可以利用一些未被保护的函数绕过 GS 保护。</p>\n<blockquote>\n<p>例子：函数中不包含 4 字节以上的缓冲区，不受到 GS 保护，函数返回前未进行任何安全检测，可以覆盖返回地址。</p>\n</blockquote>\n<figure class=\"highlight plain\"><figcaption><span>eax,1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov esp,ebp</span><br><span class=\"line\">pop ebp</span><br><span class=\"line\">retn</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"覆盖虚函数\"><a href=\"# 覆盖虚函数\" class=\"headerlink\" title=\"覆盖虚函数\"></a>覆盖虚函数 </h3><p> 程序只有在函数返回时才会 check，而在此之前没有任何检查措施，我们可以在程序检查 cookie 之前劫持程序流程，实现溢出。</p>\n<blockquote>\n<p>例子：利用 C++ 的虚函数来绕过 GS 机制。</p>\n<blockquote>\n<p>当函数中存在溢出，可能会影响到虚表指针，继而可以控制虚表指针使其指向我们可以控制的内存空间。<br>虚函数实现过程：程序根据虚表指针找到虚表，然后从虚表中取出要调用的虚函数地址，根据地址转入虚函数执行。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"攻击异常处理\"><a href=\"# 攻击异常处理\" class=\"headerlink\" title=\"攻击异常处理\"></a>攻击异常处理</h3><p>GS 对 S.E.H 没有提供保护。我们可以通过攻击异常处理绕过 GS.</p>\n<p>通过超长字符串覆盖掉异常处理函数指针，想办法触发一个异常，程序就会转入异常处理，由于异常处理函数指针已经被覆盖，我们就可以通过劫持 S.E.H 来控制程序的后续流程。</p>\n<h3 id=\"同时替换栈中和 -data 中的 Cookie\"><a href=\"# 同时替换栈中和 -data 中的 Cookie\" class=\"headerlink\" title=\"同时替换栈中和.data 中的 Cookie\"></a>同时替换栈中和.data 中的 Cookie</h3><p>cookie 的生成具有很强的随机性，因为才出来基本不可能。同时替换栈中和.data 中的 cookie 保证溢出后的一致性。</p>\n<blockquote>\n<p>例子：将 shellcode 赋值为 8 个 0x90,OD 运行断在 test 函数的 if 语句处，从 if_addr 取出 cookie，与 ebp 异或后放入 ebp-4 的位置去。（函数返回前的校验过程：程序从 ebp-4 的位置取出 cookie, 与 ebp 异或后与 if_addr 处 cookie 比较一致性），如此.data 中 cookie 成功修改为 0x90.<br>接下来控制栈中 cookie，通过超长字符串覆盖变量，修改 cookie。<br>布置 shellcode: 首先放 4 个 0x90 用于修改 if_addr，然后跟着弹出“failwest”的机器码，然后用 0x90 填充至 cookie 的位置，接下来跟着 90909090 与当前 ebp 异或的结果，最后再加上 4 个字节的填充和 shellcode 起始地址(用来覆盖函数返回地址)</p>\n</blockquote>\n<h1 id=\"0x03-SafeSEH：对异常处理的保护机制\"><a href=\"#0x03-SafeSEH：对异常处理的保护机制\" class=\"headerlink\" title=\"0x03 SafeSEH：对异常处理的保护机制\"></a>0x03 SafeSEH：对异常处理的保护机制 </h1><p> 在程序调用异常处理函数前，对要调用的异常处理函数进行校验，当发现函数不可靠将终止异常处理函数的调用。</p>\n<h2 id=\"校验流程\"><a href=\"# 校验流程\" class=\"headerlink\" title=\"校验流程\"></a>校验流程 </h2><p> 异常处理函数的调用是通过 RtlDispatchException()函数处理实现，SafeSEH 机制也是从此处开始。其校验流程如下：</p>\n<ul>\n<li>检查异常处理链是否位于当前程序的栈中</li>\n<li>异常处理指针是否指向当前程序栈中</li>\n<li>调用函数 RtlIsVaildHandler()对异常处理函数进行校验<ul>\n<li>异常处理函数地址是否在加载模块的内存空间</li>\n<li>判断程序是否设置了 IMAGE_DLLCHARACTERISTICS_NO_SEH 标识（标识被设置，函数返回校验失败）</li>\n<li>程序中是否包含安全 S.E.H 表，将异常处理函数地址与该表匹配，成功则继续</li>\n<li>判断是否设置 ILonly 标识。（设置此标识，证明该程序只包含.NET 编译人中间语言，校验失败）</li>\n<li>判断异常处理函数地址是否位于不可执行页上，位于，则检测 DEP 是否开启，未开启则校验成功</li>\n<li>判断系统是否允许跳转到加载模块的内存空间外执行，允许则返回成功</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>RtlIsVaildHandler()允许异常处理函数执行的情况：</p>\n<blockquote>\n<p>异常处理函数位于加载模块内存范围之外，DEP 关闭 <br> 异常处理函数位于加载模块内存范围之内，相应模块未启用 SafeSEH，且模块不是纯 IL（中间语言）.<br>异常处理函数位于加载模块内存范围之内，相应模块未启用 SafeSEH，异常处理函数地址包含在安全 SEH 表中。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"绕过 SafeSEH（不考虑 DEP 影响）\"><a href=\"# 绕过 SafeSEH（不考虑 DEP 影响）\" class=\"headerlink\" title=\"绕过 SafeSEH（不考虑 DEP 影响）\"></a>绕过 SafeSEH（不考虑 DEP 影响）</h2><ul>\n<li>攻击返回地址绕过。<ul>\n<li>一个程序启用了 SafeSEH 但是未启用 GS(或被攻击函数不受到 GS 保护)，攻击函数返回地址</li>\n</ul>\n</li>\n<li>利用虚函数绕过</li>\n<li>从堆中绕过</li>\n<li>利用未启用 SafeSEH 模块绕过</li>\n<li>利用加载模块之外的地址绕过 SafeSEH</li>\n<li></li>\n</ul>\n<h1 id=\"0x04-DEP\"><a href=\"#0x04-DEP\" class=\"headerlink\" title=\"0x04 DEP\"></a>0x04 DEP</h1><h2 id=\"介绍 -2\"><a href=\"# 介绍 -2\" class=\"headerlink\" title=\"介绍\"></a>介绍 </h2><p> 溢出攻击的根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，DEP(数据执行保护)就是用来弥补计算机对数据和代码混淆这一天然缺陷。</p>\n<p>DEP 基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p>\n<p>DEP 主要作用是阻止数据页执行代码，分为软件 DEP 和硬件 DEP.</p>\n<p>软件 DEP 即 SafeSEH，与 CPU 硬件无关。</p>\n<p>硬件 DEP 是由 Windows 利用软件模拟实现，对操作系统提供一定的保护。（硬件 DEP 才是真正的 DEP, 需要 CPU 支持，AMD 称之为 NX，Intel 称之为 XD）</p>\n<h2 id=\"攻击 DEP 方法\"><a href=\"# 攻击 DEP 方法\" class=\"headerlink\" title=\"攻击 DEP 方法\"></a>攻击 DEP 方法 </h2><h3 id=\"攻击未启用 DEP 程序\"><a href=\"# 攻击未启用 DEP 程序\" class=\"headerlink\" title=\"攻击未启用 DEP 程序\"></a> 攻击未启用 DEP 程序 </h3><h3 id=\"利用 Ret2Libc 挑战 DEP\"><a href=\"# 利用 Ret2Libc 挑战 DEP\" class=\"headerlink\" title=\"利用 Ret2Libc 挑战 DEP\"></a> 利用 Ret2Libc 挑战 DEP</h3><p>ret2libc 是 return-to-libc 的缩写，由于 DEP 不允许我们直接到非可执行也执行指令，我们需要在其他可执行的位置找到符合我们要求的指令，让这条指令替我们工作，为了控制此条指令，在指令执行后还需要一个返回指令，以便回收程序的控制权。</p>\n<h4 id=\"三种相对有效的绕过 DEP 的 exploit 方法\"><a href=\"# 三种相对有效的绕过 DEP 的 exploit 方法\" class=\"headerlink\" title=\"三种相对有效的绕过 DEP 的 exploit 方法\"></a>三种相对有效的绕过 DEP 的 exploit 方法</h4><ul>\n<li>通过跳转到 ZwSetInformationProcess 函数将 DEP 关闭后再转入 shellcode 执行</li>\n<li>通过跳转到 VirtualProtect 函数来将 shellcode 所在内存页设置为可执行状态，然后在转入 shellcode 执行</li>\n<li>通过跳转到 VIrtualAlloc 函数开辟一段具有执行权限的内存空间建，然后将 shellcode 复制到这段内存中执行</li>\n</ul>\n<h3 id=\"利用可执行内存挑战 DEP\"><a href=\"# 利用可执行内存挑战 DEP\" class=\"headerlink\" title=\"利用可执行内存挑战 DEP\"></a>利用可执行内存挑战 DEP</h3><p>有时候在进程的内存空间中会存在一段可读可写可执行的内存，如果能够将 shellcode 复制到这段内存中，并劫持程序流程，我们的 shellcode 就有执行的机会。此处需要一些运气，然而我在做实验上一向运气很差……, 如果被攻击的程序内存空间中存在这样一个可执行的数据区域，就可以直接通过 memcpy 函数将 shellcode 复制到这段内存区域中执行。</p>\n<h3 id=\"利用 -NET 挑战 DEP\"><a href=\"# 利用 -NET 挑战 DEP\" class=\"headerlink\" title=\"利用.NET 挑战 DEP\"></a>利用.NET 挑战 DEP</h3><p>.NET 的文件具有和 PE 文件一样的结构，即也具有.text 等段，这些段会被映射到内存中，也会具有一定的可执行属性。将 shellcode 放到.NET 中具有可执行属性的段中，然后让程序转入这个区域执行，就可以执行 shellcode 了。</p>\n<h3 id=\"利用 java-applet 挑战 DEP\"><a href=\"# 利用 java-applet 挑战 DEP\" class=\"headerlink\" title=\"利用 java applet 挑战 DEP\"></a>利用 java applet 挑战 DEP</h3><p>java applet 与.NET 类似，都可以被 IE 浏览器加载到客户端，而且加载到 IE 进程的内存空间后这些控件所在内存空间都具有可执行属性。</p>\n<h1 id=\"0x05-ASLR\"><a href=\"#0x05-ASLR\" class=\"headerlink\" title=\"0x05 ASLR\"></a>0x05 ASLR</h1><h2 id=\"介绍 -3\"><a href=\"# 介绍 -3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>ASLR, 通过加载程序的时候不再使用固定的基址加载，从而干扰 shellcode 定位的一种保护机制。包含了映像随机化、堆栈随机化、PEB 与 TEB 随机化。</p>\n<p>（支持 ASLR 的程序在它的 PE 头中会设置 IMAGE_DLL_CHARACTERISITCS_DYNAMIC_BASE 标识来说明，编译程序时启用 /dynmicbase 链接选项就可以支持 ASLR 了）</p>\n<h3 id=\"映像随机化\"><a href=\"# 映像随机化\" class=\"headerlink\" title=\"映像随机化\"></a>映像随机化 </h3><p> 在 PE 文件映射到内存中，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启红藕这个地址会变化。</p>\n<p>映像随机化只对加载基址的前 2 个字节做了随机处理。</p>\n<h3 id=\"堆栈随机化\"><a href=\"# 堆栈随机化\" class=\"headerlink\" title=\"堆栈随机化\"></a>堆栈随机化 </h3><p> 在程序运行时随机的选择堆栈基址，堆栈基址在打开程序的时候确定。</p>\n<h3 id=\"PEB 和 TEB 随机化\"><a href=\"#PEB 和 TEB 随机化\" class=\"headerlink\" title=\"PEB 和 TEB 随机化\"></a>PEB 和 TEB 随机化 </h3><p>TEB 存放在 FS:0 和 FS:[0x18] 处，PEB 存放在 TEB 偏移 0x30 的位置。</p>\n<h2 id=\"攻击方式\"><a href=\"# 攻击方式\" class=\"headerlink\" title=\"攻击方式\"></a>攻击方式 </h2><h3 id=\"攻击未启用 ASLR 模块\"><a href=\"# 攻击未启用 ASLR 模块\" class=\"headerlink\" title=\"攻击未启用 ASLR 模块\"></a> 攻击未启用 ASLR 模块</h3><p>ASLR 仅仅是安全机制，不支持 ASLR 的软件很多，这意味着加载基址固定，在当前进程找到这样的模块就可以利用它里面的指令作为跳板直接无视 ASLR.</p>\n<p>如：Adobe Flash Player ActiveX</p>\n<h3 id=\"利用部分覆盖进行定位内存地址\"><a href=\"# 利用部分覆盖进行定位内存地址\" class=\"headerlink\" title=\"利用部分覆盖进行定位内存地址\"></a>利用部分覆盖进行定位内存地址 </h3><p> 之前说过，映像随机化只是对映像加载基址的前 2 个字节做随机化处理，我们可覆盖这个地址的最后几个固定字节，就可以在一定范围内控制程序。<br>采用这种类似相对寻址方法来动态确定跳板指令的地址以实现调班指令的通用性。</p>\n<h3 id=\"利用 Heap-spray 技术定位内存地址\"><a href=\"# 利用 Heap-spray 技术定位内存地址\" class=\"headerlink\" title=\"利用 Heap spray 技术定位内存地址\"></a>利用 Heap spray 技术定位内存地址</h3><p>Heap spray 原理：通过申请大量的内存，占领内存中的 0x0C0C0C0C 的位置，并在这些内存中放置 0x90 和 shellcode，最后控制程序转入 0x0C0C0C0C 执行。</p>\n<h3 id=\"利用 Java-applet-heap-spray 技术定位内存地址\"><a href=\"# 利用 Java-applet-heap-spray 技术定位内存地址\" class=\"headerlink\" title=\"利用 Java applet heap spray 技术定位内存地址\"></a>利用 Java applet heap spray 技术定位内存地址 </h3><h3 id=\"为 -NET 控件禁用 ASLR\"><a href=\"# 为 -NET 控件禁用 ASLR\" class=\"headerlink\" title=\"为.NET 控件禁用 ASLR\"></a> 为.NET 控件禁用 ASLR</h3>","url":"/posts/61516/","min2read":10,"word4post":"2.8k","prev_post":{"title":"RPC 入侵：MS06-040 与 MS08-067","url":"/posts/59247/"},"next_post":{"title":"CVE-2006-3439","url":"/posts/55466/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x01- 格式化串漏洞\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">0x01 格式化串漏洞 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"介绍\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\"> 介绍 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"能够引起此漏洞的函数\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\">能够引起此漏洞的函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x02-GS 安全编译选项保护\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">0x02 GS 安全编译选项保护 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"介绍 -1\" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\"> 介绍 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"以下情况不会应用 GS\" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\">以下情况不会应用 GS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"典型突破 GS 的方法\" href = \"#\"><span class=\"toc-number\">2.3.</span> <span class=\"toc-text\">典型突破 GS 的方法 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用未保护的内存\" href = \"#\"><span class=\"toc-number\">2.3.1.</span> <span class=\"toc-text\"> 利用未保护的内存 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"覆盖虚函数\" href = \"#\"><span class=\"toc-number\">2.3.2.</span> <span class=\"toc-text\">覆盖虚函数 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"攻击异常处理\" href = \"#\"><span class=\"toc-number\">2.3.3.</span> <span class=\"toc-text\">攻击异常处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"同时替换栈中和 -data 中的 Cookie\" href = \"#\"><span class=\"toc-number\">2.3.4.</span> <span class=\"toc-text\">同时替换栈中和.data 中的 Cookie</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x03-SafeSEH：对异常处理的保护机制\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">0x03 SafeSEH：对异常处理的保护机制 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"校验流程\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\">校验流程 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"绕过 SafeSEH（不考虑 DEP 影响）\" href = \"#\"><span class=\"toc-number\">3.2.</span> <span class=\"toc-text\">绕过 SafeSEH（不考虑 DEP 影响）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x04-DEP\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">0x04 DEP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"介绍 -2\" href = \"#\"><span class=\"toc-number\">4.1.</span> <span class=\"toc-text\">介绍 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"攻击 DEP 方法\" href = \"#\"><span class=\"toc-number\">4.2.</span> <span class=\"toc-text\">攻击 DEP 方法 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"攻击未启用 DEP 程序\" href = \"#\"><span class=\"toc-number\">4.2.1.</span> <span class=\"toc-text\"> 攻击未启用 DEP 程序 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用 Ret2Libc 挑战 DEP\" href = \"#\"><span class=\"toc-number\">4.2.2.</span> <span class=\"toc-text\"> 利用 Ret2Libc 挑战 DEP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"三种相对有效的绕过 DEP 的 exploit 方法\" href = \"#\"><span class=\"toc-number\">4.2.2.1.</span> <span class=\"toc-text\">三种相对有效的绕过 DEP 的 exploit 方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用可执行内存挑战 DEP\" href = \"#\"><span class=\"toc-number\">4.2.3.</span> <span class=\"toc-text\">利用可执行内存挑战 DEP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用 -NET 挑战 DEP\" href = \"#\"><span class=\"toc-number\">4.2.4.</span> <span class=\"toc-text\">利用.NET 挑战 DEP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用 java-applet 挑战 DEP\" href = \"#\"><span class=\"toc-number\">4.2.5.</span> <span class=\"toc-text\">利用 java applet 挑战 DEP</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"0x05-ASLR\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">0x05 ASLR</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"介绍 -3\" href = \"#\"><span class=\"toc-number\">5.1.</span> <span class=\"toc-text\">介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"映像随机化\" href = \"#\"><span class=\"toc-number\">5.1.1.</span> <span class=\"toc-text\">映像随机化 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"堆栈随机化\" href = \"#\"><span class=\"toc-number\">5.1.2.</span> <span class=\"toc-text\">堆栈随机化 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"PEB 和 TEB 随机化\" href = \"#\"><span class=\"toc-number\">5.1.3.</span> <span class=\"toc-text\">PEB 和 TEB 随机化 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"攻击方式\" href = \"#\"><span class=\"toc-number\">5.2.</span> <span class=\"toc-text\">攻击方式 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"攻击未启用 ASLR 模块\" href = \"#\"><span class=\"toc-number\">5.2.1.</span> <span class=\"toc-text\"> 攻击未启用 ASLR 模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用部分覆盖进行定位内存地址\" href = \"#\"><span class=\"toc-number\">5.2.2.</span> <span class=\"toc-text\">利用部分覆盖进行定位内存地址 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用 Heap-spray 技术定位内存地址\" href = \"#\"><span class=\"toc-number\">5.2.3.</span> <span class=\"toc-text\">利用 Heap spray 技术定位内存地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"利用 Java-applet-heap-spray 技术定位内存地址\" href = \"#\"><span class=\"toc-number\">5.2.4.</span> <span class=\"toc-text\">利用 Java applet heap spray 技术定位内存地址 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"为 -NET 控件禁用 ASLR\" href = \"#\"><span class=\"toc-number\">5.2.5.</span> <span class=\"toc-text\"> 为.NET 控件禁用 ASLR</span></a></li></ol></li></ol></li></ol>","categories":[],"tags":[{"name":"漏洞","path":"api/tags/漏洞.json","url":"/tags/漏洞/"}]}